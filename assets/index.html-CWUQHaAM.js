import{_ as s,c as t,e as n,o as e}from"./app-CGJJd-cj.js";const i={};function p(l,a){return e(),t("div",null,a[0]||(a[0]=[n('<h2 id="_1-motivation" tabindex="-1"><a class="header-anchor" href="#_1-motivation"><span>1 Motivation</span></a></h2><p><a href="https://arxiv.org/abs/2411.16044" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2411.16044</a></p><blockquote><p>本质上来说，这个工作应该就是 prompt engineering / agent，都是人为设定好的规则来 tree search 目标物体，是 training-free 的</p><p>可能由于当时（2024年）模型的输入上下文长度限制，导致其无法进行类似 o3 那样的自由探索</p></blockquote><p>MLLMs 由于视觉编码器输入分辨率受限（如224×224），以及视觉上下文过于密集，<strong>容易忽视细节，只关注主要对象</strong>。</p><p>即使像 AnyRes 这样的技术能处理高分辨率，但仍有两大问题：</p><ol><li>Patch数量受限，超高分辨率图还需要下采样</li><li>所有细节平等处理，导致重要细节难以重点关注</li></ol><p><strong>Zoom Eye</strong>：把图像结构化成一棵树，根节点是全图，子节点是局部细节区域，越深层代表越精细的局部。基于树的搜索算法：Zoom in（深入节点，看局部细节）；Zoom out（回溯节点，查看其它区域）</p><ul><li>无训练 &amp; 模型无关：可以直接应用到各种现成的MLLM上</li></ul><p>流程概括：</p><ol><li>根据问题让模型初步找相关区域</li><li>设计两种置信度，指导搜索顺序</li><li>按置信度搜索树节点，直到能自信回答问题为止</li></ol><h2 id="_2-method" tabindex="-1"><a class="header-anchor" href="#_2-method"><span>2 Method</span></a></h2><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-07/image-20250429114613574.png" alt="image-20250429114613574" style="zoom:50%;"><p>树搜索：</p><ul><li>Tree Node 结构：每个节点有 <code>id</code>, <code>depth</code>, <code>value</code>, <code>children</code>，可以自定义更多字段。</li><li>Tree Search定义： <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>：树结构</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>：候选节点队列</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>：排名函数（选最高优先的节点）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>：停止条件</li></ul></li><li>基本流程： <ol><li>初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> 把根节点放进去。</li><li>每次取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> 顶端节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">n_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，判断是否满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，如果是就停止。</li><li>否则，把它的子节点加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>，再根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 排序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>。</li></ol></li></ul><p>例子：比如 DFS 搜索值为5的节点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 就是按 depth 优先、id 次优先排序，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 是判断 value 是否为5</p><h3 id="_2-1-tree-representation-for-image" tabindex="-1"><a class="header-anchor" href="#_2-1-tree-representation-for-image"><span>2.1 Tree Representation for Image</span></a></h3><p>把<strong>整张图像建模成一棵树</strong>：</p><ul><li>每个节点 <code>nt</code> 表示图像的一个<strong>局部区域</strong>（<code>I, bt</code>），<code>bt</code>是归一化的 bbox 坐标</li><li>如果节点的 patch 太大（超过视觉编码器的分辨率），就把它等分成4个小patch作为子节点</li><li>递归地细分，直到每个节点符合分辨率要求；起始节点是整张图片，<code>bt = (0, 0, 1, 1)</code></li></ul><p>由于高分辨率图像的信息非常密集，MLLM 一开始很难完全理解，所以需要让模型可以不断&quot;放大、扫视&quot;局部区域，探索更深的节点。提出两种输入方式来让 MLLM 感知局部 patch：</p><ol><li><strong>Local Input</strong>：只喂局部 patch（适合简单的 MLLMs）</li><li><strong>Global+Local Input</strong>：喂整图+局部patch（适合高级 MLLMs，采用 AnyRes 处理）</li></ol><h3 id="_2-2-ranking-function" tabindex="-1"><a class="header-anchor" href="#_2-2-ranking-function"><span>2.2 Ranking Function</span></a></h3><p>定义一个节点优先级 Ranking Function R，来控制探索顺序；用MLLM来辅助计算优先级：</p><ul><li><strong>Existing Confidence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">c_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>：这个 patch 里现在就能看到线索的概率。</li><li><strong>Latent Confidence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">c_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>：如果继续 zoom，有可能找到线索的概率。</li></ul><p>使用两个 prompt 去问 MLLM，根据输出 Yes/No 的概率的比例来作为权重：</p><ul><li><code>pe(o)</code>：“这里有 o 吗？”</li><li><code>pl(o)</code>：“继续放大能找到 o 吗？”</li></ul><p>两者加权求一个总优先级，权重 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> 根据节点深度动态调整（深度小给 latent 信号更多权重，深度大给 existing 信号更多权重）</p><h3 id="_2-3-stopping-criterion" tabindex="-1"><a class="header-anchor" href="#_2-3-stopping-criterion"><span>2.3 Stopping Criterion</span></a></h3><p>定义<strong>停止准则S</strong>，判断当前节点是否已经足够回答问题：</p><ul><li>用一个prompt <code>pa(qs)</code>问：“现在能回答问题了吗？”</li><li>MLLM 给出 &quot;Yes&quot; 的概率，如果超过阈值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span> 则停止</li></ul><hr><h3 id="_2-4-overall-search-algorithm" tabindex="-1"><a class="header-anchor" href="#_2-4-overall-search-algorithm"><span>2.4 Overall Search Algorithm</span></a></h3><p>完整流程分三步：</p><p>（1）生成视觉线索（Visual Cues）：在搜索之前，MLLM 生成跟问题相关的线索（如“狗”，“猫”等目标），线索分两类：</p><ul><li>Type1：找<strong>一个实例</strong>（比如找一只狗）</li><li>Type2：找<strong>所有实例</strong>（比如找所有的狗）</li></ul><table><thead><tr><th>问题</th><th>视觉线索</th><th>类型</th></tr></thead><tbody><tr><td>What is the color of the dog?</td><td>dog</td><td>type 1</td></tr><tr><td>What is the relative position of the dog to the cat?</td><td>dog, cat</td><td>type 1, type 1</td></tr><tr><td>How many dogs in the image?</td><td>all dogs</td><td>type 2</td></tr></tbody></table><hr><p>（2）搜索视觉线索：对每个视觉线索，构建并遍历图像树。</p><ul><li>对 Type1 线索：搜到满足条件（即S成立）的节点就停</li><li>对 Type2 线索：把所有存在线索的节点都记录下来，不设S</li></ul><hr><p>（3）答题</p><ul><li>把找到的所有相关节点的bounding box联合起来，形成一个区域</li><li>把这个区域（局部图像）和问题q一起输入MLLM，生成最终回答</li></ul>',41)]))}const o=s(i,[["render",p]]),r=JSON.parse(`{"path":"/article/3ve7xm35/","title":"ZoomEye 学习笔记","lang":"zh-CN","frontmatter":{"title":"ZoomEye 学习笔记","tags":["CV","VLM","Reasoning"],"createTime":"2025/05/07 09:49:33","permalink":"/article/3ve7xm35/","cover":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-07/image-20250429114613574.png","description":"1 Motivation https://arxiv.org/abs/2411.16044 本质上来说，这个工作应该就是 prompt engineering / agent，都是人为设定好的规则来 tree search 目标物体，是 training-free 的 可能由于当时（2024年）模型的输入上下文长度限制，导致其无法进行类似 o3 那样的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ZoomEye 学习笔记\\",\\"image\\":[\\"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-07/image-20250429114613574.png\\"],\\"dateModified\\":\\"2025-05-07T02:19:51.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://plus-wave.github.io/article/3ve7xm35/"}],["meta",{"property":"og:site_name","content":"PLUS-WAVE's Blog"}],["meta",{"property":"og:title","content":"ZoomEye 学习笔记"}],["meta",{"property":"og:description","content":"1 Motivation https://arxiv.org/abs/2411.16044 本质上来说，这个工作应该就是 prompt engineering / agent，都是人为设定好的规则来 tree search 目标物体，是 training-free 的 可能由于当时（2024年）模型的输入上下文长度限制，导致其无法进行类似 o3 那样的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-07/image-20250429114613574.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-07T02:19:51.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-07/image-20250429114613574.png"}],["meta",{"name":"twitter:image:alt","content":"ZoomEye 学习笔记"}],["meta",{"property":"article:tag","content":"Reasoning"}],["meta",{"property":"article:tag","content":"VLM"}],["meta",{"property":"article:tag","content":"CV"}],["meta",{"property":"article:modified_time","content":"2025-05-07T02:19:51.000Z"}]]},"readingTime":{"minutes":3.94,"words":1181},"git":{"updatedTime":1746584391000,"contributors":[{"name":"PLUS_WAVE","username":"","email":"wangplus_wave@foxmail.com","commits":1,"avatar":"https://gravatar.com/avatar/73d9cce6b7473bc4e3bccd9c674dc373250f563551d205366d1b3852d719f74e?d=retro"}]},"autoDesc":true,"filePathRelative":"2. CV/28. ZoomEye.md","headers":[],"categoryList":[{"id":"de90e8","sort":2,"name":" CV"}]}`);export{o as comp,r as data};
