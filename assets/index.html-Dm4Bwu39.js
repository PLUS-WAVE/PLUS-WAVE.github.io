import{_ as t,c as o,e as a,o as i}from"./app-CGJJd-cj.js";const p={};function n(r,e){return i(),o("div",null,e[0]||(e[0]=[a('<h3 id="_9-1-composition-复合" tabindex="-1"><a class="header-anchor" href="#_9-1-composition-复合"><span>9.1 Composition 复合</span></a></h3><p>类似于c中结构里有结构——class里有class</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-02/image-20230801093748678.png" alt="image-20230801093748678" style="zoom:67%;"><p><code>deque</code> 是一个已经存在的功能很多的类（两头进出的队列）；利用<code>deque</code>的功能来实现<code>queue</code>的多种操作</p><blockquote><p>该例只是复合的一种情况——设计模式 <strong>Adapter</strong></p></blockquote><h4 id="_9-1-1-复合下的构造和析构" tabindex="-1"><a class="header-anchor" href="#_9-1-1-复合下的构造和析构"><span>9.1.1 复合下的构造和析构</span></a></h4><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801095529359.png" alt="image-20230801095529359" style="zoom:67%;"><ul><li><p>构造是<mark>由内而外</mark></p><p>Container 的构造函数，编译器会自动先调用 Component 的 default 构造函数，再执行自己</p><blockquote><p>注意如果要调用 Component 的其他构造函数需要自己写出来</p><p><code>Container::Container(…): Component() { … };</code></p></blockquote></li><li><p>析构是<mark>由外而内</mark></p><p>Container 的析构函数会先执行自己，之后编译器调用 Component 的析构函数</p></li></ul><h3 id="_9-2-delegation-委托" tabindex="-1"><a class="header-anchor" href="#_9-2-delegation-委托"><span>9.2 Delegation 委托</span></a></h3><p>委托就是 Composition by reference；即通过指针把任务委托给另一个类</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101359560.png" style="zoom:50%;"><p>复合中，内部和外部是一起出现的；而委托是不同步的</p><blockquote><p>这是一个著名的设计模式——<strong>pimpl</strong> (pointer to implementation) 或者叫 “编译防火墙”</p><ul><li><p>右边怎么变动都不会影响左边</p></li><li><p>reference counting 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，b和c依然在共享</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101907977.png" alt="image-20230801101907977" style="zoom:67%;"></li></ul></blockquote>',13)]))}const m=t(p,[["render",n]]),s=JSON.parse(`{"path":"/cpp/s8lm3kpv/","title":"9 复合 委托","lang":"zh-CN","frontmatter":{"title":"9 复合 委托","createTime":"2023/08/03 17:40:22","permalink":"/cpp/s8lm3kpv/","description":"9.1 Composition 复合 类似于c中结构里有结构——class里有class image-20230801093748678 deque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作 该例只是复合的一种情况——设计模式 Adapter 9.1.1 复合下的构造和析构 image-202308...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9 复合 委托\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-23T12:28:40.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://plus-wave.github.io/cpp/s8lm3kpv/"}],["meta",{"property":"og:site_name","content":"PLUS-WAVE's Blog"}],["meta",{"property":"og:title","content":"9 复合 委托"}],["meta",{"property":"og:description","content":"9.1 Composition 复合 类似于c中结构里有结构——class里有class image-20230801093748678 deque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作 该例只是复合的一种情况——设计模式 Adapter 9.1.1 复合下的构造和析构 image-202308..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-23T12:28:40.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-23T12:28:40.000Z"}]]},"readingTime":{"minutes":1.25,"words":375},"git":{"updatedTime":1732364920000,"contributors":[{"name":"PLUS_WAVE","username":"","email":"wangplus_wave@foxmail.com","commits":1,"avatar":"https://gravatar.com/avatar/73d9cce6b7473bc4e3bccd9c674dc373250f563551d205366d1b3852d719f74e?d=retro"}]},"autoDesc":true,"filePathRelative":"notes/C++/1.面向对象高级开发 Part1/9. 9 复合 委托.md","headers":[]}`);export{m as comp,s as data};
