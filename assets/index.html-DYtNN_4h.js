import{_ as t,c as o,e as a,o as c}from"./app-CGJJd-cj.js";const p={};function r(m,e){return c(),o("div",null,e[0]||(e[0]=[a('<h2 id="_6-1-虚机制" tabindex="-1"><a class="header-anchor" href="#_6-1-虚机制"><span>6.1 虚机制</span></a></h2><p>当类中有虚函数时（无论多少个），其就会多一个指针—— <em>vptr</em> 虚指针，其会指向一个 <em>vtbl</em> 虚函数表，而 <em>vtbl</em> 中有指针一一对应指向所有的虚函数</p><p>有三个类依次继承，其中A有两个虚函数 <code>vfunc1()</code> <code>vfunc2()</code>，B改写了A的 <code>vfunc1()</code>，C又改写了B的 <code>vfunc1()</code>，子类在继承中对于虚函数会通过指针的方式进行——因为可能其会被改写</p><p>继承中，子类要继承父类<u>所有的数据和其函数调用权</u>，但虚函数可能会被改写，所以调用虚函数是==<u>动态绑定</u>==的，通过指针 <code>p</code> 找到 <code>vptr</code>，找到<code>vtbl</code>，再找到调用的第n个虚函数函数——<code>( *(p-&gt;vptr[n]) )(p)</code></p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-08/image-20230808095746683.png" alt="image-20230808095746683" style="zoom:80%;"><p>编译器在满足以下三个条件时就会做==<u>动态绑定</u>==：</p><ol><li>通过指针调用</li><li>指针是向上转型 <em>up-cast</em> ——<code>Base* basePtr = new Derived;</code></li><li>调用的是虚函数</li></ol><p>编译器就会编译成 <code>( *(p-&gt;vptr[n]) )(p)</code> 这样来调用</p><blockquote><p>例如：用一个 Shape（父类）的指针，调用 Circle（子类）的 <em>draw</em> 函数（每个形状的 <em>draw</em> 都不一样，继承自 Shape）</p><p><mark><strong>多态</strong></mark>：同样是 Shape 的指针，在链表中却指向了不同的类型</p><p><code>list&lt;Shape*&gt; Mylist</code></p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-08/image-20230808104025485.png" alt="image-20230808104025485" style="zoom:80%;"><p>多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</p></blockquote><h2 id="_6-2-动态绑定" tabindex="-1"><a class="header-anchor" href="#_6-2-动态绑定"><span>6.2 动态绑定</span></a></h2><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-08/image-20230808111646258.png" alt="image-20230808111646258" style="zoom:67%;"><p><code>a.vfunc1()</code> 是通过对象来调用，是 <em>static binding</em> 静态绑定</p><p>在汇编代码中，是通过 <em>call</em> 函数的固定地址来进行调用的</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-08/image-20230808112307107.png" alt="image-20230808112307107" style="zoom:67%;"><p><code>pa</code> 是指针，是<u>向上转型</u>，是用其调用虚函数—— <em>dynamic binding</em> 动态绑定</p><p>在汇编代码中，调用函数的时候，蓝框的操作用 <em>c语言</em> 的形式即是 —— <code>( *(p-&gt;vptr[n]) )(p)</code></p><p>下面同理</p>',17)]))}const i=t(p,[["render",r]]),d=JSON.parse(`{"path":"/cpp/v2qmi0hl/","title":"6 多态 虚机制","lang":"zh-CN","frontmatter":{"title":"6 多态 虚机制","createTime":"2023/08/14 17:48:37","permalink":"/cpp/v2qmi0hl/","description":"6.1 虚机制 当类中有虚函数时（无论多少个），其就会多一个指针—— vptr 虚指针，其会指向一个 vtbl 虚函数表，而 vtbl 中有指针一一对应指向所有的虚函数 有三个类依次继承，其中A有两个虚函数 vfunc1() vfunc2()，B改写了A的 vfunc1()，C又改写了B的 vfunc1()，子类在继承中对于虚函数会通过指针的方式进行—...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6 多态 虚机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-23T12:28:40.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://plus-wave.github.io/cpp/v2qmi0hl/"}],["meta",{"property":"og:site_name","content":"PLUS-WAVE's Blog"}],["meta",{"property":"og:title","content":"6 多态 虚机制"}],["meta",{"property":"og:description","content":"6.1 虚机制 当类中有虚函数时（无论多少个），其就会多一个指针—— vptr 虚指针，其会指向一个 vtbl 虚函数表，而 vtbl 中有指针一一对应指向所有的虚函数 有三个类依次继承，其中A有两个虚函数 vfunc1() vfunc2()，B改写了A的 vfunc1()，C又改写了B的 vfunc1()，子类在继承中对于虚函数会通过指针的方式进行—..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-23T12:28:40.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-23T12:28:40.000Z"}]]},"readingTime":{"minutes":1.8,"words":540},"git":{"updatedTime":1732364920000,"contributors":[{"name":"PLUS_WAVE","username":"","email":"wangplus_wave@foxmail.com","commits":1,"avatar":"https://gravatar.com/avatar/73d9cce6b7473bc4e3bccd9c674dc373250f563551d205366d1b3852d719f74e?d=retro"}]},"autoDesc":true,"filePathRelative":"notes/C++/2.面向对象高级开发 Part2/6. 6 多态 虚机制.md","headers":[]}`);export{i as comp,d as data};
