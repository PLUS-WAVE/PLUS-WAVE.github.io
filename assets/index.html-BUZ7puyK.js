import{_ as a,c as t,e as n,o as e}from"./app-CGJJd-cj.js";const p={};function l(i,s){return e(),t("div",null,s[0]||(s[0]=[n('<h2 id="_1-overview" tabindex="-1"><a class="header-anchor" href="#_1-overview"><span>1 Overview</span></a></h2><p><a href="https://arxiv.org/pdf/2505.00703" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/2505.00703</a></p><p><strong>将语言模型中的 CoT 推理机制与 RL 方法引入图像生成领域</strong></p><ul><li>图像生成不仅需要理解文本（prompt）含义，还要实现跨模态的、逐像素的细节合成</li><li>如何协调语义级和像素级的推理过程，是当前生成模型难以解决的问题</li></ul><p><strong>整体是基于 Janus-Pro 这样的 Unified Generation and Understanding LMM</strong></p><hr><p><strong>双层 CoT 机制</strong>（Bi-Level Chain-of-Thought）</p><p>论文提出了图像生成中的两个推理层级：</p><ul><li><strong>语义级 CoT</strong>：在图像生成前，通过对 prompt 进行深度理解与推理，规划图像的整体结构、物体布局等；本质是一个高层次的语言推理过程</li><li><strong>Token 级 CoT</strong>：在生成阶段，以 patch 为单位逐步生成图像的每个局部细节；等同于视觉版的逐步推理，处理细节、像素间连续性</li></ul><blockquote><p>Semantic-level CoT 就是相当于优化原始 prompt</p><p>这个 Token-level CoT ≈ 连续 image tokens， 其实还是相当于是生成图片进行优化，甚至还不如上一篇 <a href="https://arxiv.org/abs/2501.13926" target="_blank" rel="noopener noreferrer">Can We Generate Images with CoT</a> 有推理的感觉，他这里的 CoT 就是指的连续的 image tokens 呗（没有思维的感觉）</p><ul><li><strong>不是显式的 reasoning chain</strong>（比如“为了生成这只猫，我先想它在沙发上、然后想颜色……”这种 step-by-step 思考）</li><li>也<strong>没有中间 token 做显式 planning、修改或校准</strong></li><li>只是将自然存在的 token-by-token decoding 当作“CoT”，在训练阶段通过 reward 选择“好”的 tokens</li></ul><p><mark><strong>它的真正贡献在于策略优化而非 reasoning 建模；它借用了 CoT 的名义，但还远未构建出真正适应视觉领域的 reasoning 表达机制</strong></mark></p><p>但是 autoregressive 的图像生成符合 LLM 这种的 next token prediction 的范式，即在当前状态（已生成的 token 序列）下，选择下一个动作（token）的概率，<mark>呈现出序列决策或策略选择的特性。用 RL 进行优化是合理的</mark>，但其更应该类似于 LLM 中的 preference alignment（RLHF、DPO）</p></blockquote><hr><p><strong>BiCoT-GRPO（Bi-level CoT-guided RL with Group-Relative Patch-wise Optimization）</strong></p><p>核心优化框架：</p><ul><li><p>利用强化学习而非传统 SFT</p><blockquote><p>原因1：ULM（unified LMMs，e.g. Show-o）本身已具备基本能力，RL 可以更灵活地引导模型自主学习推理</p><p>原因2：RL 特别适合优化推理流程（而不仅仅是输出结果）</p></blockquote></li><li><p>优化流程：</p><ol><li><strong>生成语义级 CoT</strong>（prompt 解析与图像规划）</li><li>将其作为条件，指导 <strong>token 级 CoT 生成</strong></li><li>对同一 prompt 生成多个图像</li><li>用 <strong>group-relative reward</strong> 评估一组生成质量，统一反向传播优化两级 CoT</li></ol></li><li><p>奖励设计：不使用单一标准，而是使用<strong>多个视觉专家模型构成奖励集合</strong>（如BLIP、DINO等）</p><blockquote><p>避免 reward hacking，提高奖励稳定性与多样性；同时提升图像与 prompt 的一致性、视觉质量与语义合理性</p></blockquote></li></ul><h2 id="_2-method" tabindex="-1"><a class="header-anchor" href="#_2-method"><span>2 Method</span></a></h2><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505153156300.png" alt="image-20250505153156300" style="zoom:50%;"><h3 id="_2-1-双层-cot" tabindex="-1"><a class="header-anchor" href="#_2-1-双层-cot"><span>2.1 双层 CoT</span></a></h3><ol><li><p><strong>Semantic-level CoT</strong>：在生成图像之前，先进行<strong>文本层面的推理和规划</strong>，例如理解提示词中的深层意图、推断场景中应有的物体及其关系、排列和动作等。<strong>像画家在动笔前构思整体场景。</strong></p><ul><li>增强<strong>跨模态理解</strong>能力，使得生成更加符合用户真实意图</li></ul><blockquote><p>比如： Prompt: <em>&quot;A flower cultivated in the country where Amsterdam is located.&quot;</em> Semantic CoT 推理出应为*“tulip”*，而不是盲目生成花（阿姆斯特丹 → 郁金香）</p></blockquote></li><li><p><strong>Token-level CoT</strong>：在图像生成的过程中逐步生成 patch/image tokens，每个 patch 的生成依赖于前面的内容。<strong>像画家一点点绘制图像</strong>，保持局部细节和整体一致性。</p><ul><li>增强图像<strong>局部一致性</strong>和<strong>视觉连贯性</strong></li></ul></li></ol><p>Token-level CoT 详细机制：</p><p>1️⃣ <strong>输入阶段</strong>：生成 Token-level CoT 的输入是</p><ul><li>image prompt</li><li>上一步生成的 Semantic-level CoT</li><li>特殊 token <code>&lt;img_start&gt;</code>：用于告诉 ULM 开始生成图像 token</li></ul><p>2️⃣ <strong>生成阶段</strong>：ULM 会 step-by-step 地生成图像 token</p><ul><li>每个 token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的生成依赖于前面的 token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\\{t_1, ..., t_{i-1}\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li><li>这就形成了一个 token-level 的推理链（visual CoT），本质上是局部细节的递进建构过程</li><li>所有 token 生成完后，组成一个 grid（图像的 latent 表示），被送入 image decoder 解码成最终图像</li></ul><p>3️⃣ <strong>评估阶段</strong>：</p><ul><li>对于每个 image prompt，会生成 N 个图像（N 组 token-level CoT）</li><li>每个图像会被送入多个 vision experts（HPM、Detector、VQA、ORM）</li><li>得到每个图像的 reward 分数</li><li>再通过 GRPO： <ul><li>比较该图像的 reward 相对于同组（同 prompt）的其他图像</li><li>用于更新模型参数，让模型偏好那些 token-level CoT 更高质量的图像路径</li></ul></li></ul><p>这个 Token-level CoT 其实还是相当于是生成图片进行优化，甚至还不如上一篇 <a href="https://arxiv.org/abs/2501.13926" target="_blank" rel="noopener noreferrer">Can We Generate Images with CoT</a> 有推理的感觉，他这里的 CoT 就是指的连续的 image tokens 呗（没有思维的感觉）</p><ul><li><strong>不是显式的 reasoning chain</strong>（比如“为了生成这只猫，我先想它在沙发上、然后想颜色……”这种 step-by-step 思考）</li><li>也<strong>没有中间 token 做显式 planning、修改或校准</strong></li><li>只是将自然存在的 token-by-token decoding 当作“CoT”，在训练阶段通过 reward 选择“好”的 tokens</li></ul><h3 id="_2-2-bicot-grpo" tabindex="-1"><a class="header-anchor" href="#_2-2-bicot-grpo"><span>2.2 BiCoT-GRPO</span></a></h3><blockquote><p>GRPO（Group Relative Policy Optimization）是 DeepSeek 提出的一种 RL 策略优化框架。它通过<strong>成组地评估生成样本质量的相对表现</strong></p></blockquote><p>🧩 BiCoT-GRPO结构：</p><ol><li><strong>语义级CoT生成阶段</strong>： <ul><li>输入 Image Prompt 和设定的 prompt（Reasoning Instruction）</li><li>输出语义推理文本（semantic-level CoT）</li></ul></li><li><strong>图像生成阶段</strong>： <ul><li>输入 Image Prompt + 语义级 CoT + <code>&lt;img_start&gt; </code>标记</li><li>通过 token-level CoT 逐步生成图像 tokens，再由解码器转换成图像</li></ul></li></ol><p>🔁 奖励机制：</p><ul><li>为了稳定奖励信号，设计了<strong>视觉专家集成打分器（Ensemble of Vision Experts）</strong>，包括多个图像理解模型（例如CLIP、Inception等）共同对生成图像打分</li><li>生成多个图像（N个）后比较它们的相对质量，使用<strong>组内相对得分</strong>而非绝对打分</li></ul><h3 id="_2-3-ensemble-of-generation-rewards" tabindex="-1"><a class="header-anchor" href="#_2-3-ensemble-of-generation-rewards"><span>2.3 Ensemble of Generation Rewards</span></a></h3><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505154225729.png" alt="image-20250505154225729" style="zoom:50%;"><p>为了评估生成图像的质量，BiCoT-GRPO 不使用固定规则，而是设计了一个 <strong>多专家融合的奖励机制（ensemble of reward models）</strong>，从多个视角对图像进行评分，确保奖励的全面性与鲁棒性，避免模型专注于“破解”某个单一奖励函数</p><p>四类 vision experts：</p><ol><li><p><strong>Human Preference Model (HPM)</strong>：衡量图像的审美和对提示语的契合度</p><ul><li>使用 HPS 或 ImageReward</li><li>机制：模型基于大量人类标注的图像排名学习，输出人类偏好评分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mtext>HPM</mtext></msub></mrow><annotation encoding="application/x-tex">R_{\\text{HPM}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">HPM</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li><p><strong>Object Detector</strong>：判断图像中目标的<strong>存在性</strong>、<strong>数量</strong>、<strong>空间关系</strong>。</p><ul><li>GroundingDINO, YOLO-World</li><li>机制：检测提示语中所有对象 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>obj</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\\text{obj}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord text"><span class="mord">obj</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 是否出现在图像中；计算： <ul><li>存在性得分（是否检测到该对象）；</li><li>空间得分（如位置是否正确，使用 IoU 与相对方向）；</li><li>数量得分（检测数量是否正确）；</li></ul></li><li>奖励函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mtext>Det</mtext></msub></mrow><annotation encoding="application/x-tex">R_{\\text{Det}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Det</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： <ul><li>if spatial relationship in the prompt → 0.6 × 空间得分 + 0.4 × 存在性得分</li><li>if number in the prompt → 检测数量正确与否</li><li>else → 平均存在性得分</li></ul></li></ul></li><li><p><strong>Visual Question Answering (VQA) Model</strong>：判断目标是否存在，属性是否匹配。</p><ul><li><p>BLIP、GIT、LLaVA</p></li><li><p>机制：将 image prompt 中的目标+属性转化为问句（如：&quot;A red dog?&quot;），让模型回答是否存在：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mtext>VQA</mtext></msub><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mfrac><msubsup><mi>P</mi><mi>i</mi><mtext>Yes</mtext></msubsup><mrow><msubsup><mi>P</mi><mi>i</mi><mtext>Yes</mtext></msubsup><mo>+</mo><msubsup><mi>P</mi><mi>i</mi><mtext>No</mtext></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">R_{\\text{VQA}} = \\frac{1}{K} \\sum_i \\frac{P_i^{\\text{Yes}}}{P_i^{\\text{Yes}} + P_i^{\\text{No}}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">VQA</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.796em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183em;"><span style="top:-2.2869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8231em;"><span style="top:-2.4231em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Yes</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8231em;"><span style="top:-2.4231em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">No</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Yes</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.99em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul></li><li><p><strong>Output Reward Model (ORM)</strong>：判断图像与提示整体是否对齐。</p><ul><li>OneVision 微调后的 LLaVA</li><li>机制：直接输入整个 image prompt，模型输出是否匹配的概率（与 VQA 类似，但输入是整个 image prompt）</li></ul></li></ol><p>融合：对每个专家的输出进行平均，得到最终的 reward <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R = \\frac{1}{N} \\sum_{i=1}^N R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>',39)]))}const r=a(p,[["render",l]]),o=JSON.parse(`{"path":"/article/3accgqlr/","title":"T2I-R1 学习笔记","lang":"zh-CN","frontmatter":{"title":"T2I-R1 学习笔记","tags":["CV","Generation","Reasoning"],"createTime":"2025/05/05 16:23:38","permalink":"/article/3accgqlr/","cover":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505153156300.png","description":"1 Overview https://arxiv.org/pdf/2505.00703 将语言模型中的 CoT 推理机制与 RL 方法引入图像生成领域 图像生成不仅需要理解文本（prompt）含义，还要实现跨模态的、逐像素的细节合成 如何协调语义级和像素级的推理过程，是当前生成模型难以解决的问题 整体是基于 Janus-Pro 这样的 Unified ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"T2I-R1 学习笔记\\",\\"image\\":[\\"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505153156300.png\\"],\\"dateModified\\":\\"2025-05-09T02:46:28.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://plus-wave.github.io/article/3accgqlr/"}],["meta",{"property":"og:site_name","content":"PLUS-WAVE's Blog"}],["meta",{"property":"og:title","content":"T2I-R1 学习笔记"}],["meta",{"property":"og:description","content":"1 Overview https://arxiv.org/pdf/2505.00703 将语言模型中的 CoT 推理机制与 RL 方法引入图像生成领域 图像生成不仅需要理解文本（prompt）含义，还要实现跨模态的、逐像素的细节合成 如何协调语义级和像素级的推理过程，是当前生成模型难以解决的问题 整体是基于 Janus-Pro 这样的 Unified ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505153156300.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-09T02:46:28.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2025-05-05/image-20250505153156300.png"}],["meta",{"name":"twitter:image:alt","content":"T2I-R1 学习笔记"}],["meta",{"property":"article:tag","content":"Reasoning"}],["meta",{"property":"article:tag","content":"Generation"}],["meta",{"property":"article:tag","content":"CV"}],["meta",{"property":"article:modified_time","content":"2025-05-09T02:46:28.000Z"}]]},"readingTime":{"minutes":6.81,"words":2042},"git":{"updatedTime":1746758788000,"contributors":[{"name":"PLUS_WAVE","username":"","email":"wangplus_wave@foxmail.com","commits":5,"avatar":"https://gravatar.com/avatar/73d9cce6b7473bc4e3bccd9c674dc373250f563551d205366d1b3852d719f74e?d=retro"}]},"autoDesc":true,"filePathRelative":"2. CV/26. T2I-R1.md","headers":[],"categoryList":[{"id":"de90e8","sort":2,"name":" CV"}]}`);export{r as comp,o as data};
