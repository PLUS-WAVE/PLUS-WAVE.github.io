---
title: é€’å½’ä¸‹é™è¯­æ³•åˆ†æå®éªŒå®ç°
tags: 
    - Compiler
createTime: 2023/10/29 10:24:54
permalink: /article/01ml4a12/
---

æºç å¯ä»¥çœ‹[Githubä¸Šçš„ä»“åº“](https://github.com/PLUS-WAVE/A-UESTCer-s-Code/tree/master/B.%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C)

ç°åœ¨å‰é¢ï¼š

ç”±äºæœ¬äººå¯¹ç¼–è¯‘æŠ€æœ¯å¹¶æ— å…´è¶£ï¼ˆæˆ‘è§‰å¾—æˆ‘è¿™ç§æ•°å­—åŠ¨æ¼«æ–¹å‘çš„æ ¹æœ¬æ²¡å¿…è¦åšå®éªŒğŸ˜…ï¼‰ï¼Œæ‰€ä»¥åªå®Œæˆ**æœ€åŸºæœ¬çš„ Icoding** ä¸Šçš„å†…å®¹ï¼Œè€Œ**å…¨éƒ¨éç»ˆç»“ç¬¦å¯¹åº”å‡½æ•°**çš„å®ç°ï¼Œæˆ‘å®åœ¨æ— å¿ƒä¹Ÿæ— åŠ›ï¼Œ==**å®Œæ•´ä»£ç åœ¨æœ€å**==

<!-- more -->

> ç‰¹åˆ«é¸£è°¢ï¼š
>
> æœ¬æ–‡æ˜¯æˆ‘é€šè¿‡å­¦ä¹ åˆ†æå‰äººå¤§ä½¬çš„ä»£ç è€Œå¾—å‡ºçš„ â€”â€” [å®ååƒé¦™èœ](https://blog.csdn.net/qq_61980594/article/details/130890376?spm=1001.2014.3001.5502)ï¼ˆå¤§ä½¬æˆ‘ç»™ä½ è·ªäº†ï¼‰
>
> ç‰¹åˆ«æ„Ÿè°¢ï¼Œæ²¡æœ‰ä»–çš„ä»£ç ï¼Œæ ¹æœ¬ä¸çŸ¥é“ Icoding çš„æ£€æŸ¥è§„åˆ™ï¼Œå†æ¬¡åæ§½ Icoding é¢˜ç›®æè¿°èƒ½ä¸èƒ½å¤šæ‰“å‡ ä¸ªå­—ï¼Œä¸€äº›æè¿°æ¨¡æ¨¡ç³Šç³Šçš„ï¼Œè¿˜æœ‰ä¸€äº›ç»†èŠ‚ä¹Ÿä¸æ¸…æ¥šï¼Œæ•´ä½“ç»“æ„ä¹Ÿæ¨¡ç³Šï¼Œ**ç‹—å±ï¼ï¼ï¼**

" *rdlab2.h* "ï¼š

æ³¨æ„è¿™é‡Œé¢å£°æ˜äº†ä¸€ä¸ªå…¨å±€å˜é‡ `cur_token`

```cpp
#include <stddef.h>
#include "node_type.h"

enum yytokentype {
	num_INT = 258,
	num_FLOAT = 259,

	Y_ID = 260,

	Y_INT = 261,
	Y_VOID = 262,
	Y_CONST = 263,
	Y_IF = 264,
	Y_ELSE = 265,
	Y_WHILE = 266,
	Y_BREAK = 267,
	Y_CONTINUE = 268,
	Y_RETURN = 269,

	Y_ADD = 270,
	Y_SUB = 271,
	Y_MUL = 272,
	Y_DIV = 273,
	Y_MODULO = 274,
	Y_LESS = 275,
	Y_LESSEQ = 276,
	Y_GREAT = 277,
	Y_GREATEQ = 278,
	Y_NOTEQ = 279,
	Y_EQ = 280,
	Y_NOT = 281,
	Y_AND = 282,
	Y_OR = 283,
	Y_ASSIGN = 284,

	Y_LPAR = 285,
	Y_RPAR = 286,
	Y_LBRACKET = 287,
	Y_RBRACKET = 288,
	Y_LSQUARE = 289,
	Y_RSQUARE = 290,
	Y_COMMA = 291,
	Y_SEMICOLON = 292,

	Y_FLOAT = 293
};

typedef struct _TokenType{
	enum yytokentype token;
	union {
		int		ivalue;
		float   fvalue;
		char*	svalue;
	}attr;
}TokenType;


void set_cur_tok_index(int ind); // æ²¡ç”¨åˆ°
int get_cur_tok_index(); // æ²¡ç”¨åˆ°
TokenType advance();
extern TokenType cur_token;


///Non-terminatorï¼Œä¸çŸ¥é“åœ¨å“ªç”¨ï¼Œæ²¡æœ‰ç”¨åˆ°
enum Non_terminator
{
    ã€‚ã€‚ã€‚
};

typedef struct _ast ast;
typedef struct _ast *past;

struct _ast{
	int ivalue;
	float fvalue;
	char* svalue;
	node_type nodeType;
	past left;
	past right;
	past if_cond;
	past next;
};


// åº“æä¾›çš„å‡½æ•°
past rd_block();
past rd_array_subscripts();

past newAstNode();
past newID(char* value); // æ²¡ç”¨åˆ°
past newInt(int value);

// è¦å®Œæˆçš„å‡½æ•°
past rd_call_paras();
past rd_relexp();
past rd_stmt();
```



## 1 èŠ‚ç‚¹è®¾è®¡

Icodingç»™å‡ºçš„èŠ‚ç‚¹æ˜¯è¿™æ ·çš„ï¼š

å…¶å®ä¸åˆç†ï¼Œè¯¥èŠ‚ç‚¹çš„å¦‚æœæ˜¯æ“ä½œç¬¦ï¼Œåªèƒ½ä¿å­˜åˆ° `ivalue` ä¸­ï¼Œå¯ `ivalue` ä¸€çœ‹å°±æ˜¯ä¿å­˜æ•´å‹æ•°å€¼çš„ï¼Œä½†æ”¹ä¸äº†å…¶æ•°æ®ç»“æ„ï¼Œåªèƒ½å°†å°±ç”¨

```cpp
typedef struct _ast ast;
typedef struct _ast *past;
struct _ast{
	int ivalue; // è¿™ä¸‰ä¸ªå‚¨å­˜èŠ‚ç‚¹çš„å€¼
	float fvalue;
	char* svalue;
	node_type nodeType; // èŠ‚ç‚¹ç±»å‹
	past left;
	past right;
	past if_cond; // if_cond ä»…é™äº if è¯­å¥ä¸­çš„æ¡ä»¶
	past next; // å¹¶åˆ—å…³ç³»
};
```

> åªæœ‰ `if` è¯­å¥èŠ‚ç‚¹æ‰æœ‰â€œä¸‰åªè„šâ€



**å¹¶åˆ—å…³ç³»å¿…é¡»ç”± next æŒ‡é’ˆä¸²è”**

å¹¶åˆ—å…³ç³»é€šå¸¸å‡ºç°åœ¨å‚æ•°åˆ—è¡¨ï¼šåœ¨å‡½æ•°æˆ–æ–¹æ³•çš„å®šä¹‰ä¸­ï¼Œå‚æ•°é€šå¸¸æ˜¯å¹¶åˆ—çš„ï¼Œå®ƒä»¬çš„é¡ºåºä¸å£°æ˜é¡ºåºç›¸åŒã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªå‡½æ•°å®šä¹‰çš„ASTï¼Œå…¶ä¸­å‚æ•° `param1` å’Œ `param2` æ˜¯å¹¶åˆ—çš„ï¼š

`param1` å’Œ `param2` æ˜¯å‡½æ•°å‚æ•°çš„å¹¶åˆ—èŠ‚ç‚¹

```
[FunctionDeclaration]
â”œâ”€â”€ [Parameter param1]
â””â”€â”€ [Parameter param2]
```

## 2 NodeType

è¿™äº›`node_type`æ˜¯ä¸åŒç±»å‹çš„èŠ‚ç‚¹ç±»å‹ï¼ˆå£°æ˜ã€è¡¨è¾¾å¼ã€è¯­å¥ç­‰ï¼‰æšä¸¾å€¼ï¼Œç®€è¦æè¿°ï¼š

1. **Expression Kinds**ï¼ˆè¡¨è¾¾å¼ç±»å‹ï¼‰:
   - `CALL_EXPR`: å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼
   - `BLOCK_EXPR`: å—è¡¨è¾¾å¼
   - `INTEGER_LITERAL`: æ•´æ•°æ–‡å­—
   - `FLOATING_LITERAL`: æµ®ç‚¹æ•°æ–‡å­—
   - `IMAGINARY_LITERAL`: è™šæ•°æ–‡å­—
   - `STRING_LITERAL`: å­—ç¬¦ä¸²æ–‡å­—
   - `CHARACTER_LITERAL`: å­—ç¬¦æ–‡å­—
   - `UNARY_OPERATOR`: ä¸€å…ƒæ“ä½œç¬¦è¡¨è¾¾å¼
   - `ARRAY_SUBSCRIPT_EXPR`: æ•°ç»„ä¸‹æ ‡è¡¨è¾¾å¼
   - `BINARY_OPERATOR`: äºŒå…ƒæ“ä½œç¬¦è¡¨è¾¾å¼
2. **Statement Kinds**ï¼ˆè¯­å¥ç±»å‹ï¼‰:
   - `COMPOUND_STMT`: å¤åˆè¯­å¥ï¼ˆå—ï¼‰
   - `IF_STMT`: if è¯­å¥
   - `WHILE_STMT`: while è¯­å¥
   - `FOR_STMT`: for è¯­å¥
   - `CONTINUE_STMT`: continue è¯­å¥
   - `BREAK_STMT`: break è¯­å¥
   - `RETURN_STMT`: return è¯­å¥
   - `NULL_STMT`: ç©ºè¯­å¥
   - `DECL_STMT`: å£°æ˜è¯­å¥

> å…¶å®å¾ˆå¤šéƒ½æ²¡ç”¨åˆ°ï¼Œæ‰€ä»¥ä¸‹é¢æˆ‘çš„ä»£ç ä¸å¤ªä¸¥è°¨ï¼Œæ„Ÿè§‰ Icoding æ£€æŸ¥äº†åƒæ²¡æ£€æŸ¥ä¸€æ ·
>



## 3 å…·ä½“å®ç°

1. ä»¥"new"å¼€å¤´çš„å‡½æ•°ï¼ˆä¾‹å¦‚ `newWhileStmt`ã€`newIfStmt`ã€`newCompoundStmt`ã€`newBinaryOper`ã€`newParaDecl`ã€`newBreakStmt`ã€`newContinueStmt` å’Œ `newReturnStmt`ï¼‰æ˜¯ç”¨äºåˆ›å»ºæ–°çš„ASTèŠ‚ç‚¹çš„å‡½æ•°ã€‚è¿™äº›å‡½æ•°ç”¨äºæ„é€ ASTçš„ä¸åŒèŠ‚ç‚¹ç±»å‹ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°çš„<u>**ASTèŠ‚ç‚¹**</u>ã€‚è¿™äº›å‡½æ•°é€šå¸¸æ¥å—ä¸€äº›å‚æ•°ï¼Œç”¨äºæŒ‡å®šèŠ‚ç‚¹çš„å±æ€§å’Œå­èŠ‚ç‚¹ã€‚
2. ä»¥ "rd" å¼€å¤´çš„å‡½æ•°ï¼ˆä¾‹å¦‚ `rd_add_exp`ã€`rd_mul_exp`ã€`rd_unary_exp`ã€`rd_primary_exp`ã€`rd_l_or_exp`ã€`rd_l_and_exp` å’Œ `rd_eq_exp`ï¼‰æ˜¯ç”¨äºæ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰çš„å‡½æ•°ã€‚å®ƒä»¬æ‰§è¡Œé€’å½’ä¸‹é™è¯­æ³•åˆ†æï¼Œæ ¹æ®æ–‡æ³•è§„åˆ™é€æ­¥æ„é€ ASTçš„ä¸åŒéƒ¨åˆ†ã€‚è¿™äº›å‡½æ•°é€šå¸¸è¿”å›<u>**ASTçš„ä¸€éƒ¨åˆ†**</u>ï¼Œå¦‚è¡¨è¾¾å¼ã€è¿ç®—ç¬¦ç­‰ã€‚

### 3.1 â€œnewâ€ åˆ›å»ºå‡½æ•°

#### 3.1.1 äºŒå…ƒæ“ä½œèŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„äºŒå…ƒæ“ä½œèŠ‚ç‚¹
past newBinaryOper(int oper, past left, past right) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸ºäºŒè¿›åˆ¶æ“ä½œç¬¦
        node->nodeType = BINARY_OPERATOR;
        // å­˜å‚¨æ“ä½œç¬¦
        node->ivalue = oper;
        // å­˜å‚¨å·¦å³æ“ä½œæ•°
        node->left = left;
        node->right = right;
    }
    return node;
}
```

ä¸‹å›¾ä¸­ï¼Œæ–¹æ‹¬å· `[]` è¡¨ç¤ºèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹åŒ…å«ä¸åŒçš„å€¼ï¼Œå¦‚ `5` å’Œ `3` æ˜¯æ•´æ•°èŠ‚ç‚¹ï¼Œ`+` å’Œ `*` æ˜¯äºŒå…ƒæ“ä½œèŠ‚ç‚¹

```
       [*]
      /   \
    [+]    [2]
   /   \
  [5]  [3]

```

#### 3.1.2 å£°æ˜å¼•ç”¨è¡¨è¾¾å¼èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„å£°æ˜å¼•ç”¨è¡¨è¾¾å¼èŠ‚ç‚¹
past newDeclRefExp(char *name, past left, past right) {  
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸ºå£°æ˜å¼•ç”¨è¡¨è¾¾å¼
        node->nodeType = DECL_REF_EXPR;
        // å­˜å‚¨åç§°
        node->svalue = name;
        // å­˜å‚¨å·¦å³å­èŠ‚ç‚¹
        node->left = left;
        node->right = right;
    }
    return node;
}
```

ä¾‹å¦‚ï¼š

```cpp
x = 42;
```

åœ¨è¿™ä¸ªç‰‡æ®µä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå˜é‡å£°æ˜ `int x`ï¼Œç„¶åå°†å…¶åˆå§‹åŒ–ä¸º `42`ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `newDeclRefExp` å‡½æ•°æ¥è¡¨ç¤ºå˜é‡ `x` çš„å¼•ç”¨

```cpp
past left = newDeclRefExp("x", NULL, NULL);
```

è¿™è¡Œä»£ç åˆ›å»ºäº†ä¸€ä¸ªå£°æ˜å¼•ç”¨è¡¨è¾¾å¼èŠ‚ç‚¹ï¼Œè¡¨ç¤ºå˜é‡ `x` çš„å¼•ç”¨ã€‚`"x"` æ˜¯æ ‡è¯†ç¬¦çš„åç§°ï¼Œ`NULL` è¢«ç”¨ä½œå·¦å³å­èŠ‚ç‚¹ï¼Œå› ä¸ºåœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­ï¼Œæ²¡æœ‰å­èŠ‚ç‚¹ã€‚è¿™ä¸ªèŠ‚ç‚¹å¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼è¡¨ç¤ºï¼š

è¿™ä¸ªèŠ‚ç‚¹è¡¨ç¤ºäº†å¯¹å˜é‡ `x` çš„å¼•ç”¨

```
   [x]
```

æ¥ä¸‹æ¥ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›åˆ›å»ºä¸€ä¸ªè¡¨ç¤ºæ•´ä¸ªåˆå§‹åŒ–è¯­å¥çš„èµ‹å€¼è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ä¸Šé¢çš„ `newBinaryOper` å‡½æ•°ï¼š

```cpp
past assignment_expr = newBinaryOper(Y_ASSIGN, identifier_ref, newInt(42));
```

è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ ‡è¯†ç¬¦å¼•ç”¨èŠ‚ç‚¹ä½œä¸ºå·¦æ“ä½œæ•°ï¼Œå°†æ•´æ•°å¸¸é‡èŠ‚ç‚¹ï¼ˆ`newInt(42)`ï¼‰ä½œä¸ºå³æ“ä½œæ•°ï¼Œå¹¶å°†æ“ä½œç¬¦ `Y_ASSIGN` ä¼ é€’ç»™ `oper` å‚æ•°ã€‚è¿™å°†åˆ›å»ºä¸€ä¸ªè¡¨ç¤ºèµ‹å€¼æ“ä½œçš„äºŒå…ƒæ“ä½œèŠ‚ç‚¹

```
       [=]
      /   \
    [x]   [42]
```

#### 3.1.3 while è¯­å¥èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„ while è¯­å¥èŠ‚ç‚¹
past newWhileStmt(past condition, past body) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º while è¯­å¥
        node->nodeType = WHILE_STMT;
        // å­˜å‚¨æ¡ä»¶è¡¨è¾¾å¼å’Œå¾ªç¯ä½“
        node->left = condition;
        node->right = body;
    }
    return node;
}
```

ç¤ºä¾‹ï¼Œè¡¨ç¤ºä¸€ä¸ªç®€å•çš„ `while` å¾ªç¯ï¼š

```cpp
while (Condition) {
    Body
}
```

å¯¹åº”çš„è¯­æ³•æ ‘ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š

```
     [WHILE_STMT]
       /       \
 [Condition]    [Body]
```

#### 3.1.4 if è¯­å¥èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„ if è¯­å¥èŠ‚ç‚¹
past newIfStmt(past condition, past ifBody, past elseBody) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º if è¯­å¥
        node->nodeType = IF_STMT;
        // å­˜å‚¨æ¡ä»¶è¡¨è¾¾å¼ã€if åˆ†æ”¯å’Œelseåˆ†æ”¯
        node->if_cond = condition;
        node->left = ifBody;
        node->right = elseBody;
    }
    return node;
}
```

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ `if` è¯­å¥çš„ç¤ºä¾‹ï¼š

```cpp
if (Condition) {
    IF_BODY
} else {
    ELSE_BODY
}
```

å¯¹åº”çš„æŠ½è±¡è¯­æ³•æ ‘ç»“æ„ï¼š

```
           [IF_STMT]
        /      |      \
[Condition] [IF_BODY] [ELSE_BODY]
```

#### 3.1.5 break è¯­å¥èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„ break è¯­å¥èŠ‚ç‚¹
past newBreakStmt() {   
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º break è¯­å¥
        node->nodeType = BREAK_STMT;
    }
    return node;
}
```

"break" è¯­å¥é€šå¸¸ç”¨äºä»å¾ªç¯ä¸­è·³å‡ºï¼Œä¾‹å¦‚ `for` æˆ– `while` å¾ªç¯ï¼›<u>è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹</u>ï¼Œå› ä¸ºå®ƒä¸åŒ…å«è¡¨è¾¾å¼æˆ–æ“ä½œæ•°

```
[BREAK_STMT]
```

#### 3.1.6 continue è¯­å¥èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„ continue è¯­å¥èŠ‚ç‚¹
past newContinueStmt() {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º continue è¯­å¥
        node->nodeType = CONTINUE_STMT;
    }
    return node;
}
```

åŒç†ï¼Œå®ƒä¸åŒ…å«è¡¨è¾¾å¼æˆ–æ“ä½œæ•°ï¼Œ<u>æ²¡æœ‰å·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹</u>

```
[CONTINUE_STMT]
```

#### 3.1.7 return è¯­å¥èŠ‚ç‚¹

```cpp
// åˆ›å»ºä¸€ä¸ªæ–°çš„ return è¯­å¥èŠ‚ç‚¹
past newReturnStmt(past left, past right) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º return è¯­å¥
        node->nodeType = RETURN_STMT;
        // å­˜å‚¨è¿”å›è¡¨è¾¾å¼
        node->left = left;
        node->right = right;
    }
    return node;
}
```

å¦‚æœå‡½æ•°ä¸è¿”å›ä»»ä½•å€¼ï¼ˆå³ `return;`ï¼‰ï¼Œé‚£ä¹ˆå·¦å­èŠ‚ç‚¹å°†ä¸ºç©ºï¼Œå³å­èŠ‚ç‚¹ä¹Ÿå°†ä¸ºç©º

åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œ`right` é€šå¸¸ä¼šä¸ºç©ºï¼Œå› ä¸ºä¸€ä¸ª `return` è¯­å¥åªèƒ½è¿”å›ä¸€ä¸ªå€¼

æ‰€ä»¥ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥åªä¼ é€’ä¸€ä¸ªå€¼ç»™ `newReturnStmt` å‡½æ•°ï¼Œå°†å…¶ä½œä¸º `left` å‚æ•°ï¼Œè€Œå°† `right` å‚æ•°è®¾ç½®ä¸º `NULL`ã€‚

ç¤ºä¾‹ï¼š

```cpp
past returnValue = astAddExp(); // å‡è®¾ astAddExp() è¿”å›ä¸€ä¸ªè¡¨è¾¾å¼èŠ‚ç‚¹
past returnStatement = newReturnStmt(returnValue, NULL);
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œ`returnValue` æ˜¯ä½ è¦è¿”å›çš„å€¼çš„è¡¨è¾¾å¼èŠ‚ç‚¹ï¼Œè€Œ `returnStatement` å°±æ˜¯ä¸€ä¸ªåŒ…å«äº†è¿™ä¸ªè¿”å›å€¼çš„ `return` è¯­å¥èŠ‚ç‚¹ã€‚

```
 [RETURN_STMT]
      |
 [ReturnValue]
```

### 3.2 â€œrdâ€ è§£æå‡½æ•°

#### 3.2.1 åŸºæœ¬è¡¨è¾¾å¼

```
PrimaryExp: Y_LPAR Exp Y_RPAR
          | LVal
          | num_INT
          | num_FLOAT
          
LVal: Y_ID
    | Y_ID ArraySubscripts
```

- LVal
  - ç®€å•æ ‡è¯†ç¬¦ï¼š`x`
  - å¸¦æœ‰æ•°ç»„ä¸‹æ ‡çš„æ ‡è¯†ç¬¦ï¼š`arr[2]`
- `42`ï¼šä¸€ä¸ªæ•´æ•°å¸¸é‡
- `(x + y)`ï¼šä¸€ä¸ªç”¨æ‹¬å·æ‹¬èµ·æ¥çš„è¡¨è¾¾å¼



```cpp
// è§£æåŸºæœ¬è¡¨è¾¾å¼
past rd_primary_exp() {
    past node = NULL; // åˆå§‹åŒ–èŠ‚ç‚¹ä¸ºNULL

    if (cur_token.token == Y_LPAR) { // (è¡¨è¾¾å¼)
        advance(); 
        node = rd_add_exp(); // è§ä¸‹é¢çš„rd_add_exp()å‡½æ•°
        if (cur_token.token != Y_RPAR) { // ç¼ºå³æ‹¬å·
            return NULL; 
        }
        advance(); 
    } else if (cur_token.token == Y_ID) { // LVal
        char *s = cur_token.attr.svalue;
        past Arr = rd_array_subscripts();
        node = newDeclRefExp(s, Arr, NULL);
        advance();
    } else if (cur_token.token == num_INT) { 
        node = newInt(cur_token.attr.ivalue); // æ„é€ æ•´æ•°èŠ‚ç‚¹
        advance(); 
    } else if (cur_token.token == num_FLOAT) { 
        node = newAstNode(); // æ„é€ æµ®ç‚¹æ•°èŠ‚ç‚¹
        advance(); 
        node->fvalue = cur_token.attr.fvalue;
    }

    return node; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

æœ€åå…¶å¾—åˆ°çš„ä¼šæ˜¯ï¼š

- è·ŸåŠ æ³•è¡¨è¾¾å¼ä¸€æ ·çš„ï¼ˆè§ä¸‹é¢ï¼‰
- ä¸€ä¸ªå•èŠ‚ç‚¹ï¼šæ ‡è¯†ç¬¦ / æ•°ç»„ / æ•´æ•° / æµ®ç‚¹æ•°

#### 3.2.2 ä¸€å…ƒè¡¨è¾¾å¼

```
UnaryExp: PrimaryExp
        | Y_ID Y_LPAR Y_RPAR
        | Y_ID Y_LPAR CallParams Y_RPAR
        | Y_ADD UnaryExp
        | Y_SUB UnaryExp
        | Y_NOT UnaryExp                    
```

- PrimaryExp
- `-x`ï¼šè¡¨ç¤ºå¯¹å˜é‡ x å–è´Ÿ
- `!flag`ï¼šè¡¨ç¤ºå¯¹å˜é‡ flag è¿›è¡Œé€»è¾‘éæ“ä½œ
- `++i`ï¼šè¡¨ç¤ºå¯¹å˜é‡ i è¿›è¡Œé€’å¢æ“ä½œ
- `func(a, b)`ï¼šä¸€ä¸ªå‡½æ•°è°ƒç”¨è¡¨è¾¾å¼



```cpp
// è§£æä¸€å…ƒè¡¨è¾¾å¼
past rd_unary_exp() {
    past node = rd_primary_exp(); // è·å–åŸºæœ¬è¡¨è¾¾å¼

    while (node == NULL) { // å½“åŸºæœ¬è¡¨è¾¾å¼ä¸ºç©ºæ—¶
        if (cur_token.token == Y_ID) { // å½“å½“å‰ç¬¦å·ä¸ºæ ‡è¯†ç¬¦æ—¶
            char *s = cur_token.attr.svalue;
            advance();
            if (cur_token.token == Y_LPAR) {
                advance();
				past params = NULL;
                if (cur_token.token != Y_RPAR) {
                    params = rd_call_paras(); // è§£æå‡½æ•°è°ƒç”¨å‚æ•°
                }
                node = newDeclRefExp(s, params, NULL); // æ„é€ å£°æ˜å¼•ç”¨è¡¨è¾¾å¼
            }
        } else if (cur_token.token == Y_ADD || cur_token.token == Y_SUB || cur_token.token == Y_NOT) { // å½“å½“å‰ç¬¦å·ä¸ºåŠ å·ã€å‡å·æˆ–å–åç¬¦å·
            int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
            advance(); 
            past operand = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼
            node = newBinaryOper(oper, NULL, operand); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
        } else {
            return NULL; // æ— æ³•åŒ¹é…å…¶ä»–æƒ…å†µï¼Œè¿”å›ç©º
        }
    }

    return node; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

ä¾‹1ï¼š

```cpp
-5
```

åˆå§‹æ—¶ï¼Œ`cur_token.token` æŒ‡å‘ç¬¦å· `-`

ç¬¬ä¸€æ¬¡å¾ªç¯ï¼š

- å½“å‰ä¸æ˜¯åŸºæœ¬è¡¨è¾¾å¼ï¼Œè¿›å…¥å¾ªç¯
- å½“å‰ç¬¦å·ä¸æ˜¯ `Y_ID`ï¼Œè¿›å…¥ `else if`
- è®°å½•è¿ç®—ç¬¦ä¸ºå‡å· (`Y_SUB`)
- è°ƒç”¨ `advance()` å‘å‰ç§»åŠ¨ï¼Œç°åœ¨å½“å‰æ ‡è®°æ˜¯æ•°å­— `5`
- å†æ¬¡è°ƒç”¨ `rd_unary_exp()` å‡½æ•°ï¼Œè¿™æ¬¡**æ˜¯åŸºæœ¬è¡¨è¾¾å¼**ï¼Œä¼šè·å–ä¸€å…ƒè¡¨è¾¾å¼ï¼Œå¾—åˆ°èŠ‚ç‚¹è¡¨ç¤ºæ•°å­— `5`
- ä½¿ç”¨ `newBinaryOper()` æ„å»ºä¸€ä¸ªäºŒå…ƒæ“ä½œè¡¨è¾¾å¼ï¼Œæ“ä½œç¬¦ä¸ºå‡å·ï¼Œå·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ä¸ºæ•°å­— `5`

ç»“æœä¸ºï¼š

```
  [-]
   |
  [5]
```

ä¾‹2ï¼š

```cpp
func(a, b)
```

æœ€åå¾—åˆ°ï¼š

```
       [DECL_REF_EXPR]
            /   \
       "func"   [a] â€”â€” [b]                           
```

#### 3.2.3 åŠ æ³•è¡¨è¾¾å¼

```
AddExp: MulExp
      | AddExp Y_ADD MulExp
      | AddExp Y_SUB MulExp
```

```cpp
// è§£æåŠ æ³•è¡¨è¾¾å¼
past rd_add_exp() {
    past left = rd_mul_exp(); // è·å–ä¹˜æ³•è¡¨è¾¾å¼

    while (cur_token.token == Y_ADD || cur_token.token == Y_SUB) { // å½“å½“å‰ç¬¦å·ä¸ºåŠ å·æˆ–å‡å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); // å‘å‰ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç¬¦å·
        past right = rd_mul_exp(); // è·å–ä¹˜æ³•è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

é€šè¿‡ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥è§£é‡Šè¿™ä¸ªå‡½æ•°ï¼Œå‡è®¾æœ‰å¦‚ä¸‹çš„åŠ æ³•è¡¨è¾¾å¼ï¼š

```cpp
2 + 3 - 1
```

åˆå§‹æ—¶ï¼Œ`cur_token.token` ä¼šæŒ‡å‘æ•°å­— `2` çš„æ ‡è®°ï¼Œè°ƒç”¨ `rd_mul_exp()` å‡½æ•°æ¥è·å–ä¹˜æ³•è¡¨è¾¾å¼ï¼Œå¾—åˆ°èŠ‚ç‚¹è¡¨ç¤ºæ•°å­— `2`

ç¬¬ä¸€æ¬¡å¾ªç¯ï¼š

- å½“å‰æ ‡è®°æ˜¯ `Y_ADD`ï¼Œç¬¦åˆå¾ªç¯æ¡ä»¶ï¼Œæ‰€ä»¥è¿›å…¥å¾ªç¯
- è®°å½•è¿ç®—ç¬¦ä¸ºåŠ å· `Y_ADD`
- è°ƒç”¨ `advance()` å‘å‰ç§»åŠ¨ï¼Œç°åœ¨å½“å‰æ ‡è®°æ˜¯æ•°å­— `3`
- è°ƒç”¨ `rd_mul_exp()` å‡½æ•°æ¥è·å–ä¹˜æ³•è¡¨è¾¾å¼ï¼Œå¾—åˆ°èŠ‚ç‚¹è¡¨ç¤ºæ•°å­— `3`
- ä½¿ç”¨ `newBinaryOper()` æ„å»ºä¸€ä¸ªäºŒå…ƒæ“ä½œè¡¨è¾¾å¼ï¼Œæ“ä½œç¬¦ä¸ºåŠ å·ï¼Œå·¦å­æ ‘ä¸ºæ•°å­— `2`ï¼Œå³å­æ ‘ä¸ºæ•°å­— `3`

ç»“æœä¸ºï¼š

```
   [+]
  /   \
[2]   [3]
```

ç¬¬äºŒæ¬¡å¾ªç¯ï¼š

- å½“å‰æ ‡è®°æ˜¯ `Y_SUB`ï¼Œç¬¦åˆå¾ªç¯æ¡ä»¶ï¼Œæ‰€ä»¥è¿›å…¥å¾ªç¯
- è®°å½•è¿ç®—ç¬¦ä¸ºå‡å· `Y_SUB`
- è°ƒç”¨ `advance()` å‘å‰ç§»åŠ¨ï¼Œç°åœ¨å½“å‰æ ‡è®°æ˜¯æ•°å­— `1`
- è°ƒç”¨ `rd_mul_exp()` å‡½æ•°æ¥è·å–ä¹˜æ³•è¡¨è¾¾å¼ï¼Œå¾—åˆ°èŠ‚ç‚¹è¡¨ç¤ºæ•°å­— `1`
- ä½¿ç”¨ `newBinaryOper()` æ„å»ºä¸€ä¸ªäºŒå…ƒæ“ä½œè¡¨è¾¾å¼ï¼Œæ“ä½œç¬¦ä¸ºå‡å·ï¼Œå·¦å­æ ‘ä¸ºä¹‹å‰æ„å»ºçš„è¡¨è¾¾å¼ï¼Œå³å­æ ‘ä¸ºæ•°å­— `1`

ç»“æœä¸ºï¼š

```
      [-]
     /   \
   [+]    [1]
  /   \
[2]   [3]
```

#### 3.2.4 ä¹˜æ³•è¡¨è¾¾å¼

```
MulExp: UnaryExp
      | MulExp Y_MUL UnaryExp
      | MulExp Y_DIV UnaryExp
      | MulExp Y_MODULO UnaryExp
```

```cpp
// å‡½æ•°å®šä¹‰ï¼šè§£æä¹˜æ³•è¡¨è¾¾å¼
past rd_mul_exp() {
    past left = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼

    while (cur_token.token == Y_MUL || cur_token.token == Y_DIV || cur_token.token == Y_MODULO) { // å½“å½“å‰ç¬¦å·ä¸ºä¹˜å·ã€é™¤å·æˆ–å–æ¨¡ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); // å‘å‰ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç¬¦å·
        past right = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

è·Ÿä¸Šé¢çš„åŒç†ï¼Œä¾‹ï¼š

```cpp
4 * 3 / 2
```

æœ€ç»ˆå¾—åˆ°ï¼š

```
      [/]
     /   \
   [*]   [2]
  /   \
[4]   [3]
```

#### 3.2.5 ç›¸ç­‰è¡¨è¾¾å¼

```
EqExp: RelExp
     | RelExp Y_EQ EqExp
     | RelExp Y_NOTEQ EqExp
```

```cpp
// è§£æç›¸ç­‰è¡¨è¾¾å¼
past rd_eq_exp() {
    past left = rd_relexp(); // è·å–å…³ç³»è¡¨è¾¾å¼

    while (cur_token.token == Y_EQ || cur_token.token == Y_NOTEQ) { // å½“å½“å‰ç¬¦å·ä¸ºç­‰å·æˆ–ä¸ç­‰å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_relexp(); // è·å–å…³ç³»è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

è·Ÿä¹‹å‰çš„åŠ æ³•è¡¨è¾¾å¼ç›¸ä¼¼ï¼Œä¾‹ï¼š

```cpp
3 == 4 != 5
```

```
     [!=]
    /    \
 [==]    [5]
 /  \
[3] [4]
```

#### 3.2.6 å…³ç³»è¡¨è¾¾å¼

```
RelExp: AddExp
      | AddExp Y_LESS RelExp
      | AddExp Y_GREAT RelExp
      | AddExp Y_LESSEQ RelExp
      | AddExp Y_GREATEQ RelExp
```

```cpp
// è§£æå…³ç³»è¡¨è¾¾å¼
past rd_relexp() {
    past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼

    while (true) {
        switch (cur_token.token) {
            case Y_LESS:
            case Y_LESSEQ:
            case Y_GREAT:
            case Y_GREATEQ: { // å½“å½“å‰ç¬¦å·ä¸ºå°äºã€å°äºç­‰äºã€å¤§äºæˆ–å¤§äºç­‰äºæ—¶
                int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
                advance(); 
                past right = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
                left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
                break;
            }
            default:
                return left; // è¿”å›è¡¨è¾¾å¼æ ‘
        }
    }
}
```

å…¶å®è·ŸåŠ æ³•è¡¨è¾¾å¼ä¹Ÿæ˜¯åŒç†çš„ï¼Œä¸€ä¸ª while å¾ªç¯é€’å½’æ„å»ºï¼Œä¾‹ï¼š

```cpp
3 < 4 <= 5
```

```
     [<=]
    /    \
  [<]    [5]
 /   \
[3]  [4]
```

#### 3.2.7 é€»è¾‘ä¸è¡¨è¾¾å¼

```
LAndExp: EqExp
       | EqExp Y_AND LAndExp
```

```cpp
// è§£æé€»è¾‘ä¸è¡¨è¾¾å¼
past rd_l_and_exp() {
    past left = rd_eq_exp(); // è·å–ç›¸ç­‰è¡¨è¾¾å¼

    while (cur_token.token == Y_AND) { // å½“å½“å‰ç¬¦å·ä¸ºé€»è¾‘ä¸ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_eq_exp(); // è·å–ç›¸ç­‰è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

è·Ÿä¹‹å‰çš„åŠ æ³•è¡¨è¾¾å¼ç›¸ä¼¼ï¼Œä¾‹ï¼š

```cpp
true && false && true
```

```
        [&&]
       /    \
    [&&]    [TRUE]
   /    \
[TRUE] [FALSE]
```

#### 3.2.8 é€»è¾‘æˆ–è¡¨è¾¾å¼

```
LOrExp: LAndExp
      | LAndExp Y_OR LOrExp
```

```cpp
// è§£æé€»è¾‘æˆ–è¡¨è¾¾å¼
past rd_l_or_exp() {
    past left = rd_l_and_exp(); // è·å–é€»è¾‘ä¸è¡¨è¾¾å¼

    while (cur_token.token == Y_OR) { // å½“å½“å‰ç¬¦å·ä¸ºé€»è¾‘æˆ–ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_l_and_exp(); // è·å–é€»è¾‘ä¸è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}
```

åŒç†ï¼Œä¾‹ï¼š

```cpp
a || b || c
```

```
        [&&]
       /    \
    [&&]    [c]
   /    \
 [a]    [b]
```

#### 3.2.9 å‡½æ•°è°ƒç”¨å‚æ•°

```
CallParams: Exp
          | Exp Y_COMMA CallParams
```

```cpp
// è§£æå‡½æ•°è°ƒç”¨å‚æ•°
past rd_call_paras() {
    past head = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
    past current = head;

    while (cur_token.token) {
        if (cur_token.token != Y_COMMA) { // å½“å½“å‰ç¬¦å·ä¸ä¸ºé€—å·æ—¶
            break;
        }
        advance(); 
        past new_node = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
        current->next = new_node;
        current = current->next;
    }

    return head; // è¿”å›å‚æ•°é“¾è¡¨å¤´èŠ‚ç‚¹
}
```

`CallParams` èŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ª**é“¾è¡¨**ï¼Œé€šè¿‡ `next` æŒ‡é’ˆè¡¨ç¤ºå¹¶åˆ—å…³ç³»ï¼Œä¾‹å¦‚ï¼š

```cpp
func(a, b, c)
```

å¾—åˆ°ï¼š

```
 head
  |
 [a] -> [b] -> [c]
```

#### 3.2.10 è¯­å¥

```
Stmt: LVal Y_ASSIGN Exp Y_SEMICOLON
    | Y_SEMICOLON
    | Exp Y_SEMICOLON
    | Block
    | Y_WHILE Y_LPAR LOrExp Y_RPAR Stmt
    | Y_IF Y_LPAR LOrExp Y_RPAR Stmt
    | Y_IF Y_LPAR LOrExp Y_RPAR Stmt Y_ELSE Stmt
    | Y_BREAK Y_SEMICOLON
    | Y_CONTINUE Y_SEMICOLON
    | Y_RETURN Exp Y_SEMICOLON
    | Y_RETURN Y_SEMICOLON
```

```cpp
// è§£æè¯­å¥
past rd_stmt() {
    switch (cur_token.token) {
        case Y_ID: { // LVal å¼€å¤´ â€”â€”â€”â€” èµ‹å€¼è¯­å¥
            char *s = cur_token.attr.svalue; // å¤„ç†LValï¼ˆç­‰å·å·¦è¾¹ï¼‰
            past Arr = rd_array_subscripts();
            past lval = newDeclRefExp(s, Arr, NULL);
            advance(); 
            if (cur_token.token != Y_ASSIGN) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼ï¼ˆç­‰å·å³è¾¹ï¼‰
            if (cur_token.token != Y_SEMICOLON) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newBinaryOper(Y_ASSIGN, lval, left); // è¿”å›èµ‹å€¼è¡¨è¾¾å¼
        }
        case Y_SEMICOLON: { // åˆ†å·å¼€å¤´ â€”â€”â€”â€” ç©ºè¯­å¥
            advance(); 
            return NULL; 
        }
        case Y_LBRACKET: { // å·¦å¤§æ‹¬å·å¼€å¤´ â€”â€”â€”â€” ä»£ç å—
            advance(); 
            past block = rd_block(); // è·å–å—è¯­å¥
            if (cur_token.token != Y_RBRACKET) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return block; // è¿”å›å—è¯­å¥
        }
        case Y_WHILE: { // WHILEè¯­å¥
            advance(); 
            if (cur_token.token != Y_LPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å·¦æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past condition = rd_l_or_exp(); // è·å–é€»è¾‘æˆ–è¡¨è¾¾å¼
            if (cur_token.token != Y_RPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å³æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past stmt = rd_stmt(); // è·å–è¯­å¥
            return newWhileStmt(condition, stmt); // è¿”å›WHILEè¯­å¥
        }
        case Y_IF: { // IFè¯­å¥
            advance(); 
            if (cur_token.token != Y_LPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å·¦æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL;
            }
            advance(); 
            past condition = rd_l_or_exp(); // è·å–é€»è¾‘æˆ–è¡¨è¾¾å¼
            if (cur_token.token != Y_RPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å³æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past if_stmt = rd_stmt(); // è·å–è¯­å¥
            if (cur_token.token != Y_ELSE) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯ELSEå…³é”®å­— â€”â€”â€”â€” æ— else
                return newIfStmt(condition, if_stmt, NULL); // è¿”å›IFè¯­å¥
            }
            advance(); 
            past else_stmt = rd_stmt(); // è·å–ELSEåˆ†æ”¯è¯­å¥
            return newIfStmt(condition, if_stmt, else_stmt); // è¿”å›IF-ELSEè¯­å¥
        }
        case Y_BREAK: { // BREAKè¯­å¥
            advance(); 
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newBreakStmt(); // è¿”å›BREAKè¯­å¥
        }
        case Y_CONTINUE: { // CONTINUEè¯­å¥
            advance(); 
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newContinueStmt(); // è¿”å›CONTINUEè¯­å¥
        }
        case Y_RETURN: { // RETURNè¯­å¥
            advance(); 
            past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL;
            }
            advance();
            return newReturnStmt(left, NULL); // è¿”å›RETURNè¯­å¥
        }
        default:
            return NULL;
    }
}

```

ç¤ºä¾‹1: èµ‹å€¼è¯­å¥ (case `Y_ID`)

```cpp
x[1] = 42;
```

```
   [=]
  /   \
x[1]  42
```

ç¤ºä¾‹2: ç©ºè¯­å¥ (case `Y_SEMICOLON`)

```cpp
; //  NULL
```

ç¤ºä¾‹3: ä»£ç å— (case `Y_LBRACKET`)

```cpp
{
    x = 1;
    y = 2;
}
```

```
    [Block]
   /       \
(x = 1)  (y = 2)
```

ç¤ºä¾‹4: WHILE è¯­å¥ (case `Y_WHILE`)

```cpp
while (x > 0) {
    x = x - 1;
}
```

```
       [WHILE]
      /       \
   [>]         [=]
  /   \       /   \
[x]   [0]    [x]   [-]
           	      /   \
        	    [x]   [1]
```

ç¤ºä¾‹5: IF è¯­å¥ (case `Y_IF`)

```cpp
if (x > 0) {
    x = x - 1;
} else {
    x = x + 1;
}
```

```
            [IF]
    /        |        \
(x > 0) (x = x - 1) (x = x + 1)
```

ç¤ºä¾‹6: BREAK è¯­å¥ (case `Y_BREAK`)

```cpp
break;
```

```
  [BREAK]
```

ç¤ºä¾‹7: CONTINUE è¯­å¥ (case `Y_CONTINUE`)

```cpp
continue;
```

```
  [CONTINUE]
```

ç¤ºä¾‹8: RETURN è¯­å¥ (case `Y_RETURN`)

```cpp
return 5;
```

```
  [RETURN]
     |
     5
```

## 4 å®Œæ•´ä»£ç 

```cpp
#include "rdlab2.h"
#include <stdbool.h>

// å£°æ˜å‡½æ•°
past newBinaryOper(int oper, past left, past right);  // åˆ›å»ºä¸€ä¸ªæ–°çš„äºŒå…ƒæ“ä½œèŠ‚ç‚¹
past newDeclRefExp(char *name, past left, past right);  // åˆ›å»ºä¸€ä¸ªæ–°çš„å£°æ˜å¼•ç”¨è¡¨è¾¾å¼èŠ‚ç‚¹
past newWhileStmt(past condition, past body);  // åˆ›å»ºä¸€ä¸ªæ–°çš„ while è¯­å¥èŠ‚ç‚¹
past newIfStmt(past condition, past ifBody, past elseBody);  // åˆ›å»ºä¸€ä¸ªæ–°çš„ if è¯­å¥èŠ‚ç‚¹
past newBreakStmt();  // åˆ›å»ºä¸€ä¸ªæ–°çš„ break è¯­å¥èŠ‚ç‚¹
past newContinueStmt();  // åˆ›å»ºä¸€ä¸ªæ–°çš„ continue è¯­å¥èŠ‚ç‚¹
past newReturnStmt(past left, past right);  // åˆ›å»ºä¸€ä¸ªæ–°çš„ return è¯­å¥èŠ‚ç‚¹

past rd_add_exp();  // è§£æåŠ æ³•å’Œå‡æ³•è¡¨è¾¾å¼
past rd_mul_exp();  // è§£æä¹˜æ³•ã€é™¤æ³•å’Œå–æ¨¡è¡¨è¾¾å¼
past rd_unary_exp();  // è§£æä¸€å…ƒè¡¨è¾¾å¼
past rd_primary_exp();  // è§£æåŸºæœ¬è¡¨è¾¾å¼
past rd_l_or_exp();  // è§£æé€»è¾‘æˆ–è¡¨è¾¾å¼
past rd_l_and_exp();  // è§£æé€»è¾‘ä¸è¡¨è¾¾å¼
past rd_eq_exp();  // è§£æç›¸ç­‰æ€§è¡¨è¾¾å¼
past rd_call_paras();  // è§£æå‡½æ•°è°ƒç”¨å‚æ•°åˆ—è¡¨
past rd_relexp();  // è§£æå…³ç³»è¿ç®—è¡¨è¾¾å¼
past rd_stmt();  // è§£æè¯­å¥

// å‡½æ•°å®šä¹‰

// åˆ›å»ºä¸€ä¸ªæ–°çš„äºŒå…ƒæ“ä½œèŠ‚ç‚¹
past newBinaryOper(int oper, past left, past right) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸ºäºŒè¿›åˆ¶æ“ä½œç¬¦
        node->nodeType = BINARY_OPERATOR;
        // å­˜å‚¨æ“ä½œç¬¦
        node->ivalue = oper;
        // å­˜å‚¨å·¦å³æ“ä½œæ•°
        node->left = left;
        node->right = right;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„å£°æ˜å¼•ç”¨è¡¨è¾¾å¼èŠ‚ç‚¹
past newDeclRefExp(char *name, past left, past right) {  
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸ºå£°æ˜å¼•ç”¨è¡¨è¾¾å¼
        node->nodeType = DECL_REF_EXPR;
        // å­˜å‚¨åç§°
        node->svalue = name;
        // å­˜å‚¨å·¦å³å­èŠ‚ç‚¹
        node->left = left;
        node->right = right;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„ while è¯­å¥èŠ‚ç‚¹
past newWhileStmt(past condition, past body) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º while è¯­å¥
        node->nodeType = WHILE_STMT;
        // å­˜å‚¨æ¡ä»¶è¡¨è¾¾å¼å’Œå¾ªç¯ä½“
        node->left = condition;
        node->right = body;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„ if è¯­å¥èŠ‚ç‚¹
past newIfStmt(past condition, past ifBody, past elseBody) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º if è¯­å¥
        node->nodeType = IF_STMT;
        // å­˜å‚¨æ¡ä»¶è¡¨è¾¾å¼ã€if åˆ†æ”¯å’Œelseåˆ†æ”¯
        node->if_cond = condition;
        node->left = ifBody;
        node->right = elseBody;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„ break è¯­å¥èŠ‚ç‚¹
past newBreakStmt() {   
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º break è¯­å¥
        node->nodeType = BREAK_STMT;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„ continue è¯­å¥èŠ‚ç‚¹
past newContinueStmt() {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º continue è¯­å¥
        node->nodeType = CONTINUE_STMT;
    }
    return node;
}

// åˆ›å»ºä¸€ä¸ªæ–°çš„ return è¯­å¥èŠ‚ç‚¹
past newReturnStmt(past left, past right) {
    past node = newAstNode();
    if (node) {
        // è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸º return è¯­å¥
        node->nodeType = RETURN_STMT;
        // å­˜å‚¨è¿”å›è¡¨è¾¾å¼
        node->left = left;
        node->right = right;
    }
    return node;
}

// è§£æåŸºæœ¬è¡¨è¾¾å¼
past rd_primary_exp() {
    past node = NULL; // åˆå§‹åŒ–èŠ‚ç‚¹ä¸ºNULL

    if (cur_token.token == Y_LPAR) { // (è¡¨è¾¾å¼)
        advance(); 
        node = rd_add_exp(); // è§ä¸‹é¢çš„rd_add_exp()å‡½æ•°
        if (cur_token.token != Y_RPAR) { // ç¼ºå³æ‹¬å·
            return NULL; 
        }
        advance(); 
    } else if (cur_token.token == Y_ID) { // LVal
        char *s = cur_token.attr.svalue;
        past Arr = rd_array_subscripts();
        node = newDeclRefExp(s, Arr, NULL);
		advance();
    } else if (cur_token.token == num_INT) { 
        node = newInt(cur_token.attr.ivalue); // æ„é€ æ•´æ•°èŠ‚ç‚¹
        advance(); 
    } else if (cur_token.token == num_FLOAT) { 
        node = newAstNode(); // æ„é€ æµ®ç‚¹æ•°èŠ‚ç‚¹
        advance(); 
        node->fvalue = cur_token.attr.fvalue;
    }

    return node; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æä¸€å…ƒè¡¨è¾¾å¼
past rd_unary_exp() {
    past node = rd_primary_exp(); // è·å–åŸºæœ¬è¡¨è¾¾å¼

    while (node == NULL) { // å½“åŸºæœ¬è¡¨è¾¾å¼ä¸ºç©ºæ—¶
        if (cur_token.token == Y_ID) { // å½“å½“å‰ç¬¦å·ä¸ºæ ‡è¯†ç¬¦æ—¶
            char *s = cur_token.attr.svalue;
            advance();
            if (cur_token.token == Y_LPAR) {
                advance();
				past params;
                if (cur_token.token != Y_RPAR) {
                    params = rd_call_paras(); // è§£æå‡½æ•°è°ƒç”¨å‚æ•°
                }
                node = newDeclRefExp(s, params, NULL); // æ„é€ å£°æ˜å¼•ç”¨è¡¨è¾¾å¼
            }
        } else if (cur_token.token == Y_ADD || cur_token.token == Y_SUB || cur_token.token == Y_NOT) { // å½“å½“å‰ç¬¦å·ä¸ºåŠ å·ã€å‡å·æˆ–å–åç¬¦å·
            int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
            advance(); 
            past operand = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼
            node = newBinaryOper(oper, NULL, operand); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
        } else {
            return NULL; // æ— æ³•åŒ¹é…å…¶ä»–æƒ…å†µï¼Œè¿”å›ç©º
        }
    }

    return node; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æåŠ æ³•è¡¨è¾¾å¼
past rd_add_exp() {
    past left = rd_mul_exp(); // è·å–ä¹˜æ³•è¡¨è¾¾å¼

    while (cur_token.token == Y_ADD || cur_token.token == Y_SUB) { // å½“å½“å‰ç¬¦å·ä¸ºåŠ å·æˆ–å‡å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_mul_exp(); // è·å–ä¹˜æ³•è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æä¹˜æ³•è¡¨è¾¾å¼
past rd_mul_exp() {
    past left = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼

    while (cur_token.token == Y_MUL || cur_token.token == Y_DIV || cur_token.token == Y_MODULO) { // å½“å½“å‰ç¬¦å·ä¸ºä¹˜å·ã€é™¤å·æˆ–å–æ¨¡ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_unary_exp(); // è·å–ä¸€å…ƒè¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}


// è§£æç›¸ç­‰è¡¨è¾¾å¼
past rd_eq_exp() {
    past left = rd_relexp(); // è·å–å…³ç³»è¡¨è¾¾å¼

    while (cur_token.token == Y_EQ || cur_token.token == Y_NOTEQ) { // å½“å½“å‰ç¬¦å·ä¸ºç­‰å·æˆ–ä¸ç­‰å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_relexp(); // è·å–å…³ç³»è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æå…³ç³»è¡¨è¾¾å¼
past rd_relexp() {
    past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼

    while (true) {
        switch (cur_token.token) {
            case Y_LESS:
            case Y_LESSEQ:
            case Y_GREAT:
            case Y_GREATEQ: { // å½“å½“å‰ç¬¦å·ä¸ºå°äºã€å°äºç­‰äºã€å¤§äºæˆ–å¤§äºç­‰äºæ—¶
                int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
                advance(); 
                past right = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
                left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
                break;
            }
            default:
                return left; // è¿”å›è¡¨è¾¾å¼æ ‘
        }
    }
}

// è§£æé€»è¾‘ä¸è¡¨è¾¾å¼
past rd_l_and_exp() {
    past left = rd_eq_exp(); // è·å–ç›¸ç­‰è¡¨è¾¾å¼

    while (cur_token.token == Y_AND) { // å½“å½“å‰ç¬¦å·ä¸ºé€»è¾‘ä¸ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_eq_exp(); // è·å–ç›¸ç­‰è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æé€»è¾‘æˆ–è¡¨è¾¾å¼
past rd_l_or_exp() {
    past left = rd_l_and_exp(); // è·å–é€»è¾‘ä¸è¡¨è¾¾å¼

    while (cur_token.token == Y_OR) { // å½“å½“å‰ç¬¦å·ä¸ºé€»è¾‘æˆ–ç¬¦å·æ—¶
        int oper = cur_token.token; // è®°å½•è¿ç®—ç¬¦
        advance(); 
        past right = rd_l_and_exp(); // è·å–é€»è¾‘ä¸è¡¨è¾¾å¼
        left = newBinaryOper(oper, left, right); // æ„é€ äºŒå…ƒæ“ä½œè¡¨è¾¾å¼
    }

    return left; // è¿”å›è¡¨è¾¾å¼æ ‘
}

// è§£æå‡½æ•°è°ƒç”¨å‚æ•°
past rd_call_paras() {
    past head = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
    past current = head;

    while (cur_token.token) {
        if (cur_token.token != Y_COMMA) { // å½“å½“å‰ç¬¦å·ä¸ä¸ºé€—å·æ—¶
            break;
        }
        advance(); 
        past new_node = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
        current->next = new_node;
        current = current->next;
    }

    return head; // è¿”å›å‚æ•°é“¾è¡¨å¤´èŠ‚ç‚¹
}

// è§£æè¯­å¥
past rd_stmt() {
    switch (cur_token.token) {
        case Y_ID: { // LVal å¼€å¤´ â€”â€”â€”â€” èµ‹å€¼è¯­å¥
            char *s = cur_token.attr.svalue; // å¤„ç†LValï¼ˆç­‰å·å·¦è¾¹ï¼‰
            past Arr = rd_array_subscripts();
            past lval = newDeclRefExp(s, Arr, NULL);
            advance(); 
            if (cur_token.token != Y_ASSIGN) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼ï¼ˆç­‰å·å³è¾¹ï¼‰
            if (cur_token.token != Y_SEMICOLON) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newBinaryOper(Y_ASSIGN, lval, left); // è¿”å›èµ‹å€¼è¡¨è¾¾å¼
        }
        case Y_SEMICOLON: { // åˆ†å·å¼€å¤´ â€”â€”â€”â€” ç©ºè¯­å¥
            advance(); 
            return NULL; 
        }
        case Y_LBRACKET: { // å·¦å¤§æ‹¬å·å¼€å¤´ â€”â€”â€”â€” ä»£ç å—
            advance(); 
            past block = rd_block(); // è·å–å—è¯­å¥
            if (cur_token.token != Y_RBRACKET) { // è¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return block; // è¿”å›å—è¯­å¥
        }
        case Y_WHILE: { // WHILEè¯­å¥
            advance(); 
            if (cur_token.token != Y_LPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å·¦æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past condition = rd_l_or_exp(); // è·å–é€»è¾‘æˆ–è¡¨è¾¾å¼
            if (cur_token.token != Y_RPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å³æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past stmt = rd_stmt(); // è·å–è¯­å¥
            return newWhileStmt(condition, stmt); // è¿”å›WHILEè¯­å¥
        }
        case Y_IF: { // IFè¯­å¥
            advance(); 
            if (cur_token.token != Y_LPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å·¦æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL;
            }
            advance(); 
            past condition = rd_l_or_exp(); // è·å–é€»è¾‘æˆ–è¡¨è¾¾å¼
            if (cur_token.token != Y_RPAR) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯å³æ‹¬å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            past if_stmt = rd_stmt(); // è·å–è¯­å¥
            if (cur_token.token != Y_ELSE) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯ELSEå…³é”®å­— â€”â€”â€”â€” æ— else
                return newIfStmt(condition, if_stmt, NULL); // è¿”å›IFè¯­å¥
            }
            advance(); 
            past else_stmt = rd_stmt(); // è·å–ELSEåˆ†æ”¯è¯­å¥
            return newIfStmt(condition, if_stmt, else_stmt); // è¿”å›IF-ELSEè¯­å¥
        }
        case Y_BREAK: { // BREAKè¯­å¥
            advance(); 
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newBreakStmt(); // è¿”å›BREAKè¯­å¥
        }
        case Y_CONTINUE: { // CONTINUEè¯­å¥
            advance(); 
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL; 
            }
            advance(); 
            return newContinueStmt(); // è¿”å›CONTINUEè¯­å¥
        }
        case Y_RETURN: { // RETURNè¯­å¥
            advance(); 
            past left = rd_add_exp(); // è·å–åŠ æ³•è¡¨è¾¾å¼
            if (cur_token.token != Y_SEMICOLON) { // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸æ˜¯åˆ†å·ï¼Œè¯­æ³•é”™è¯¯
                return NULL;
            }
            advance();
            return newReturnStmt(left, NULL); // è¿”å›RETURNè¯­å¥
        }
        default:
            return NULL;
    }
}

```

