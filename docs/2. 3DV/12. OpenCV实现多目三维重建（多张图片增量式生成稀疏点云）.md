---
title: OpenCVå®ç°å¤šç›®ä¸‰ç»´é‡å»ºï¼ˆå¤šå¼ å›¾ç‰‡å¢é‡å¼ç”Ÿæˆç¨€ç–ç‚¹äº‘ï¼‰
tags: 
  - 3DVision
  - OpenCV
  - SfM
createTime: 2023/10/20 16:30:25
permalink: /article/tvshoi7n/
cover: https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-10-20/image-20231020200946321.png
---


ğŸŒŸåç»­çš„å®Œæˆçš„é¡¹ç›®ï¼šWindows ä¸ŠåŸºäº OpenMVG + OpenMVS çš„3Dé‡å»ºå¹³å° â€”â€” **[ğŸŒŠWAVE-3D-Reconstruction](https://github.com/PLUS-WAVE/WAVE-3D-Reconstruction)**
## 1 å¤§è‡´æµç¨‹

ä»å¤šå¼ å›¾ç‰‡é€æ­¥ç”Ÿæˆç¨€ç–ç‚¹äº‘ï¼Œè¿™ä¸ªè¿‡ç¨‹é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š

1. åˆå§‹é‡å»ºï¼š

   åˆå§‹ä¸¤å¼ å›¾ç‰‡çš„é€‰æ‹©<u>ååˆ†é‡è¦</u>ï¼Œè¿™æ˜¯æ•´ä¸ªæµç¨‹çš„åŸºç¡€ï¼Œåç»­çš„å¢å›¾éƒ½æ˜¯åœ¨è¿™ä¸¤å¼ å›¾ç‰‡çš„åŸºç¡€ä¸Šè¿›è¡Œçš„<!-- more -->

   - å¯¹äºè¾“å…¥å›¾åƒï¼Œé¦–å…ˆéœ€è¦æå–ç‰¹å¾ç‚¹ï¼ˆä¾‹å¦‚ï¼ŒSIFTã€SURFæˆ–ORBç‰¹å¾ç‚¹ï¼‰ã€‚ç„¶åï¼Œé€šè¿‡åŒ¹é…ä¸åŒå›¾åƒä¸­çš„ç‰¹å¾ç‚¹ï¼Œå»ºç«‹å®ƒä»¬ä¹‹é—´çš„å¯¹åº”å…³ç³»
   - é€šè¿‡ä¸¤å¼ å›¾åƒä¹‹é—´çš„æœ¬è´¨çŸ©é˜µ `E` ä¼°è®¡ç›¸æœºçš„å¤–å‚çŸ©é˜µï¼ˆæ—‹è½¬çŸ©é˜µ `R` å’Œå¹³ç§»å‘é‡ `T` ï¼‰ï¼Œç„¶åä½¿ç”¨**ä¸‰è§’æµ‹é‡æ³•**è®¡ç®—å‡ºä¸€äº›åˆå§‹çš„ä¸‰ç»´ç‚¹


   å…·ä½“æ“ä½œå¯ä»¥æŸ¥çœ‹[æˆ‘å‰é¢çš„åšå®¢](/article/11ohv0jz/)

2. å¢é‡å¼é‡å»ºï¼š

   ä»è¿™å¼€å§‹ï¼Œé€æ­¥å¢åŠ å›¾åƒï¼Œé€æ¸æ‰©å±•ä¸‰ç»´ç‚¹äº‘

   - æ·»åŠ æ–°çš„å›¾åƒï¼šå°†æ–°çš„å›¾åƒåŠ è½½åˆ°é‡å»ºæµç¨‹ä¸­
   - ç‰¹å¾æå–å’ŒåŒ¹é…ï¼šå¯¹æ–°çš„å›¾åƒæå–ç‰¹å¾ç‚¹å¹¶ä¸å…ˆå‰å›¾åƒåŒ¹é…ä»¥è·å¾—æ–°çš„åŒ¹é…å…³ç³»
   - ä½å§¿ä¼°è®¡ï¼šä¼°è®¡æ–°å›¾åƒç›¸å¯¹äºå…ˆå‰å›¾åƒçš„ç›¸æœºä½å§¿ï¼Œé€šå¸¸ä½¿ç”¨ `PnP`ï¼ˆ*Perspective-n-Point*ï¼‰â€”â€” åœ¨å·²çŸ¥ç›¸æœºå†…å‚æ•° `K` çš„å‰æä¸‹ï¼Œç”¨è¯¥è§’åº¦ä¸‹çš„<u>ä¸‰ç»´ç‚¹</u>ï¼ˆobject_pointsï¼‰ä¸å®ƒä»¬å¯¹åº”çš„<u>å›¾åƒç‚¹</u>ï¼ˆimage_pointsï¼‰åæ ‡ï¼Œä¼°ç®—å‡ºæ­¤æ—¶æ‹æ‘„ä½ç½®çš„ä¿¡æ¯
   - ä¸‰ç»´ç‚¹ä¸‰è§’æµ‹é‡ï¼šä½¿ç”¨æ–°çš„åŒ¹é…å¯¹å’Œä¼°è®¡çš„ä½å§¿ï¼ˆ`R`ï¼Œ`T`ï¼‰æ¥<u>ä¸‰è§’æµ‹é‡</u>ï¼Œç”Ÿæˆæ–°çš„ä¸‰ç»´ç‚¹ã€‚
   - ç‚¹äº‘åˆå¹¶ï¼šå°†æ–°ç”Ÿæˆçš„ä¸‰ç»´ç‚¹ä¸å…ˆå‰çš„ç‚¹äº‘è¿›è¡Œåˆå¹¶ï¼Œæ„å»ºä¸€ä¸ªæ›´å¤§çš„ç¨€ç–ç‚¹äº‘

3. å…¨å±€ç‚¹äº‘ä¼˜åŒ–ï¼šåœ¨ç¨€ç–ç‚¹äº‘å·²ç»ç”Ÿæˆåï¼Œå¯ä»¥ä½¿ç”¨å…¨å±€ç‚¹äº‘ä¼˜åŒ–æŠ€æœ¯ï¼Œä¾‹å¦‚**Bundle Adjustment**ï¼Œæ¥æé«˜ç‚¹äº‘çš„å‡†ç¡®æ€§

## 2 å‡†å¤‡ä»£ç 

ä¹‹å‰æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬è®²æ‰€æœ‰ä»£ç éƒ½æŒ¤åˆ°äº†mainå‡½æ•°ä¸­ï¼Œååˆ†ä¸ç¾è§‚ï¼Œç°åœ¨æˆ‘ä»¬è¿›è¡Œä¸€ä¸‹ä»£ç çš„ä¼˜åŒ–

> ç”±äºæ‰å­¦C++ï¼Œæ¯”è¾ƒèœè¯·è§è°…

### 2.1 Include.h

è¿™é‡ŒåŒ…å«äº†æ‰€æœ‰ç”¨åˆ°çš„<u>å¤´æ–‡ä»¶å’Œå®</u>ï¼Œæ–¹ä¾¿ä¹‹åä½¿ç”¨

è¿™æ¬¡ç”±äºè¦ç”¨ **Bundle Adjustment**ï¼Œæ‰€ä»¥å¼•å…¥äº† **ceres**ï¼Œå…·ä½“ç¯å¢ƒé…ç½®ä¹‹åå¯èƒ½ä¼šè¯´ï¼ˆçœŸçš„æ¯”è¾ƒéº»çƒ¦ï¼‰ï¼Œå…¶ä¸­å¤§é‡çš„ `#define` å’Œ `#pragma warning(disable: 4996)` éƒ½æ˜¯å…³äº **ceres** çš„æŠ¥é”™çš„

```cpp
#ifndef INCLUDES_H
#define INCLUDES_H

#define GLOG_NO_ABBREVIATED_SEVERITIES
#define _CRT_NONSTDC_NO_DEPRECATE
#define NOMINMAX
#define _CRT_NONSTDC_NO_WARNINGS
#pragma warning(disable: 4996)

#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <fstream>
#include <ceres/ceres.h>
#include <ceres/rotation.h>



using namespace cv;
using namespace std;
#endif // !INCLUDES_H

#pragma once
```

### 2.2 Constructor

Constructor ç±»ï¼Œå…¶ä¸­åŒ…å«äº†ä¸‰ç»´é‡å»ºçš„å‡ ä¸ªå…³é”®æ­¥éª¤çš„å‡½æ•°ï¼š

- `findCamera`ï¼šåˆå§‹æ„å»ºä½¿ç”¨çš„æ±‚å– E çŸ©é˜µå’ŒRï¼ŒTï¼ˆå…¶ä¸­åŒ…æ‹¬äº†**RANSAC**ï¼‰
- `maskoutPoints`ï¼šé€šè¿‡å†…ç‚¹æ ‡è®°maskï¼Œæ¥å¯¹ç‚¹è¿›è¡Œç­›é€‰
- `pointsReconstruct`ï¼šé€šè¿‡ Rï¼ŒT åŒ¹é…ç‚¹æ¥è¿›è¡Œä¸‰è§’åŒ–ç”Ÿæˆä¸‰ç»´ç‚¹äº‘

**Constructor.h**ï¼š

```cpp
#ifndef CONSTRUCTOR_H
#define CONSTRUCTOR_H

#include "Includes.h"
#include "Images.h"

class Constructor
{
public:
	// è¾“å…¥Kï¼Œå›¾1çš„åŒ¹é…ç‚¹ï¼Œå›¾2çš„åŒ¹é…ç‚¹ï¼›è¾“å‡ºRï¼ŒTï¼›ç‚¹ç»è¿‡ç­›é€‰
	static void findCamera(Mat K, vector<Point2f>& point1, vector<Point2f>& point2, Mat& output_R, Mat& output_T, vector<uchar>& mask);
	
	// è¾“å…¥å›¾åŒ¹é…ç‚¹ï¼Œå†…ç‚¹æ ‡è®°maskï¼›è¿”å›maskåçš„vector<Point2f>åŒ¹é…ç‚¹
	static void maskoutPoints(vector<Point2f>& input_points, vector<uchar>& input_mask);

	// è¾“å…¥å›¾ä¸€çš„Rï¼ŒTï¼ŒåŒ¹é…ç‚¹ï¼Œå›¾äºŒçš„Rï¼ŒTï¼ŒåŒ¹é…ç‚¹ï¼›è¿”å›vector<Point3f>ä¸‰ç»´ç‚¹
	static vector<Point3d>& pointsReconstruct(const Mat& K, Mat& R1, Mat& T1, Mat& R2, Mat& T2, vector<Point2f>& points1, vector<Point2f>& points2);
};


#endif // !CONSTRUCTOR_H

#pragma once
```

**Constructor.cpp**ï¼š

```cpp
#include "Constructor.h"

void Constructor::findCamera(Mat K, vector<Point2f>& point1, vector<Point2f>& point2, Mat& output_R, Mat& output_T, vector<uchar>& mask)
{
	vector<uchar> inliers;

	Mat F;
	F = findFundamentalMat(point1, point2, inliers, FM_RANSAC, 1, 0.5);
	Mat E = K.t() * F * K;

	//Mat E = findEssentialMat(point1, point2, K, RANSAC, 0.6, 1.0, inliners);
	
	mask = inliers;

	// æ ¹æ®å†…ç‚¹ç­›é€‰å‡ºæ–°çš„åŒ¹é…ç‚¹
	Constructor::maskoutPoints(point1, inliers);
	Constructor::maskoutPoints(point2, inliers);

	// åˆ†è§£EçŸ©é˜µï¼Œè·å–Rï¼ŒTçŸ©é˜µ
	int pass_count = recoverPose(E, point1, point2, K, output_R, output_T);
}


void Constructor::maskoutPoints(vector<Point2f>& input_points, vector<uchar>& input_mask)
{
	vector<Point2f> temp_points(input_points);
	input_points.clear();

	for (int i = 0; i < temp_points.size(); ++i)
	{
		if (input_mask[i])
		{
			input_points.push_back(temp_points[i]);
		}
	}
}


vector<Point3d>& Constructor::pointsReconstruct(const Mat& K, Mat& R1, Mat& T1, Mat& R2, Mat& T2, vector<Point2f>& points1, vector<Point2f>& points2)
{
	// æ„é€ æŠ•å½±çŸ©é˜µ
	Mat proj1(3, 4, CV_32FC1);
	Mat proj2(3, 4, CV_32FC1);

	// å°†æ—‹è½¬çŸ©é˜µå’Œå¹³ç§»å‘é‡åˆå¹¶ä¸ºæŠ•å½±çŸ©é˜µ
	R1.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_32FC1);
	T1.convertTo(proj1.col(3), CV_32FC1);

	R2.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_32FC1);
	T2.convertTo(proj2.col(3), CV_32FC1);

	// å°†å†…å‚çŸ©é˜µä¸æŠ•å½±çŸ©é˜µç›¸ä¹˜ï¼Œå¾—åˆ°æœ€ç»ˆçš„æŠ•å½±çŸ©é˜µ
	Mat fK;
	K.convertTo(fK, CV_32FC1);
	proj1 = fK * proj1;
	proj2 = fK * proj2;

	// ä¸‰è§’åŒ–ï¼Œå¾—åˆ°é½æ¬¡åæ ‡
	Mat point4D_homogeneous(4, points1.size(), CV_64F);
	triangulatePoints(proj1, proj2, points1, points2, point4D_homogeneous);

	// å°†é½æ¬¡åæ ‡è½¬æ¢ä¸ºä¸‰ç»´åæ ‡
	vector<Point3d> point3D;
	point3D.clear();
	point3D.reserve(point4D_homogeneous.cols);
	for (int i = 0; i < point4D_homogeneous.cols; ++i)
	{
		Mat<float> col = point4D_homogeneous.col(i);
		col /= col(3);
		point3D.push_back(Point3d(col(0), col(1), col(2)));
	}

	// å°†ä¸‰ç»´åæ ‡å­˜å‚¨åœ¨Point3då‘é‡ä¸­å¹¶è¿”å›
	return point3D;
}
```

### 2.3 Image

ä¸ºäº†å¢å›¾ï¼Œæˆ‘ä»¬éœ€è¦å­˜å‚¨å›¾åƒä¸­æ¯ä¸ªç‰¹å¾ç‚¹åœ¨ç©ºé—´ä¸­çš„å¯¹åº”ç‚¹â€”â€” **correspond_struct_idx**

Image ç±»ï¼Œå…¶ä¸­æœ‰æˆå‘˜å˜é‡ï¼š

- `Mat image`â€”â€” å­˜å‚¨å›¾åƒ
- `vector<KeyPoint> keyPoints`â€”â€” å­˜å‚¨ç‰¹å¾ç‚¹
- `Mat descriptor`â€”â€” å­˜å‚¨ç‰¹å¾æè¿°ç¬¦
- `vector<int> correspond_struct_idx`â€”â€” åŒ¹é…ç‚¹æ‰€å¯¹åº”çš„ç©ºé—´ç‚¹åœ¨ç‚¹äº‘ä¸­çš„ç´¢å¼•
- `vector<Point2f> matchedPoints`â€”â€” å­˜å‚¨åŒ¹é…ç‚¹
- `vector<Vec3b> colors`â€”â€” å­˜å‚¨åŒ¹é…ç‚¹çš„é¢œè‰²ä¿¡æ¯
- `Mat R, T`â€”â€” å­˜å‚¨ç›¸æœºçš„æ—‹è½¬çŸ©é˜µå’Œå¹³ç§»å‘é‡

åŒæ—¶è¿˜æœ‰å‡ ä¸ªå…³äºå›¾åƒå¤„ç†çš„é‡è¦å‡½æ•°ï¼š

- `Images`ï¼šæ„é€ å‡½æ•°ï¼Œè¯»å–å›¾åƒæ—¶å°±è¿›è¡Œäº†ç‰¹å¾ç‚¹çš„æå–
- `matchFeatures`ï¼šåŒ¹é…ç‰¹å¾ç‚¹
- `findColor`ï¼šæå–é¢œè‰²ä¿¡æ¯
- `getObjPointsAndImgPoints`ï¼šæ‰¾å‡ºå½“å‰åŒ¹é…ä¸­å·²ç»åœ¨ç‚¹äº‘ä¸­çš„ç‚¹ï¼Œè·å– **object_points**ï¼Œä»¥åŠ **image_points** â€”â€” ä¸º **PnP** åšå‡†å¤‡

**Image.h**ï¼š

```cpp
#ifndef IMAGES_H
#define IMAGES_H

#include "Includes.h"

class Images
{
public:
	Mat image; // å­˜å‚¨å›¾åƒ
	vector<KeyPoint> keyPoints; // å­˜å‚¨ç‰¹å¾ç‚¹
	Mat descriptor; // å­˜å‚¨ç‰¹å¾æè¿°ç¬¦
	vector<int> correspond_struct_idx; // åŒ¹é…ç‚¹æ‰€å¯¹åº”çš„ç©ºé—´ç‚¹åœ¨ç‚¹äº‘ä¸­çš„ç´¢å¼•
	vector<Point2f> matchedPoints; // å­˜å‚¨åŒ¹é…ç‚¹
	vector<Vec3b> colors; // å­˜å‚¨åŒ¹é…ç‚¹çš„é¢œè‰²ä¿¡æ¯
	Mat R, T; // å­˜å‚¨ç›¸æœºçš„æ—‹è½¬çŸ©é˜µå’Œå¹³ç§»å‘é‡

	vector<Point3f> object_points; // å‰ä¸€å¼ å›¾ä¸­åŒ¹é…ç‚¹å¯¹åº”çš„ä¸‰ç»´ç‚¹
	vector<Point2f> image_points; // åœ¨ç°å›¾åƒä¸­å¯¹åº”çš„åƒç´ ç‚¹

	// æ„é€ å‡½æ•°ï¼Œä»æŒ‡å®šè·¯å¾„è¯»å–å›¾åƒï¼Œå¹¶æå–SIFTç‰¹å¾ç‚¹å’Œæè¿°ç¬¦
	Images(string const image_paths);

	// ç‰¹å¾åŒ¹é…å‡½æ•°ï¼Œå°†å½“å‰å›¾åƒä¸å¦ä¸€ä¸ªå›¾åƒè¿›è¡Œç‰¹å¾åŒ¹é…
	void matchFeatures(Images& otherImage, vector<DMatch>& outputMatches);

	// ä»åŒ¹é…ç‚¹ä¸­æå–é¢œè‰²ä¿¡æ¯
	void findColor();

	// éå†å½“å‰åŒ¹é…ï¼Œæ‰¾å‡ºå½“å‰åŒ¹é…ä¸­å·²ç»åœ¨ç‚¹äº‘ä¸­çš„ç‚¹ï¼Œè·å–object_pointsï¼Œä»¥åŠimage_points
	void getObjPointsAndImgPoints(vector<DMatch>& matches, vector<Point3d>& all_reconstructed_points, Images& preImage);
};


#endif // !IMAGES_H
#pragma once
```

**Image.cpp**ï¼š

```cpp
#include "Images.h"


Images::Images(string const image_path) 
{
	// è¯»å–å›¾åƒ
	this->image = imread(image_path);
	if (this->image.empty()) 
	{
		cout << "Could not read image: " << image_path << endl;
	}

	// æå–SIFTç‰¹å¾ç‚¹å’Œæè¿°ç¬¦
	Ptr<SIFT> sift = SIFT::create(0, 17, 0.0000000001, 16);
	sift->detectAndCompute(this->image, noArray(), this->keyPoints, this->descriptor);

	for (int i = 0; i < keyPoints.size(); i++)
	{
		correspond_struct_idx.push_back(-1);
	}
}


void Images::findColor()
{
	// éå†æ‰€æœ‰åŒ¹é…ç‚¹
	for (Point2f& Points : this->matchedPoints)
	{	
		// è·å–åƒç´ ç‚¹çš„é¢œè‰²
		Vec3b color = this->image.at<Vec3b>(Points.y, Points.x);

		// å°†é¢œè‰²å­˜å‚¨åœ¨é¢œè‰²å‘é‡ä¸­
		this->colors.push_back(color);
	}
}


void Images::matchFeatures(Images& otherImage, vector<DMatch>& outputMatches)
{
	// æ¸…ç©ºåŒ¹é…ç‚¹
	otherImage.matchedPoints.clear();
	this->matchedPoints.clear();

	vector<vector<DMatch>> matches;
	FlannBasedMatcher matcher;

	// ä½¿ç”¨FlannBasedMatcherè¿›è¡Œç‰¹å¾åŒ¹é…
	matcher.knnMatch(this->descriptor, otherImage.descriptor, matches, 2);

	// è®¡ç®—æœ€å°è·ç¦»
	float min_dist = FLT_MAX;
	for (int r = 0; r < matches.size(); ++r)
	{
		// å¦‚æœæœ€è¿‘é‚»è·ç¦»å¤§äºæ¬¡è¿‘é‚»è·ç¦»çš„2.5å€ï¼Œåˆ™è·³è¿‡è¯¥åŒ¹é…ç‚¹
		if (matches[r][0].distance < 2.5 * matches[r][1].distance)
		{
			// è®¡ç®—æœ€å°è·ç¦»
			float dist = matches[r][0].distance;
			if (dist < min_dist)
			{
				min_dist = dist;
			}
		}
	}


	// ç­›é€‰å‡ºå¥½çš„åŒ¹é…ç‚¹
	for (int i = 0; i < matches.size(); i++)
	{
		if (matches[i][0].distance < 0.76 * matches[i][1].distance && matches[i][0].distance < 8 * max(min_dist, 10.0f))
		{
			outputMatches.push_back(matches[i][0]);
		}
	}

	// å°†åŒ¹é…ç‚¹å­˜å‚¨åœ¨matchedPointså‘é‡ä¸­
	for (int i = 0; i < outputMatches.size(); ++i)
	{
		this->matchedPoints.push_back(this->keyPoints[outputMatches[i].queryIdx].pt);
		otherImage.matchedPoints.push_back(otherImage.keyPoints[outputMatches[i].trainIdx].pt);
	}
}

// ä»åŒ¹é…ç‚¹ä¸­è·å–ä¸‰ç»´ç©ºé—´ç‚¹å’Œå›¾åƒç‚¹
void Images::getObjPointsAndImgPoints(vector<DMatch>& matches, vector<Point3d>& all_reconstructed_points, Images& preImage)
{
	// æ¸…ç©ºobject_pointså’Œimage_points
	this->object_points.clear();
	this->image_points.clear();

	// éå†æ‰€æœ‰åŒ¹é…ç‚¹
	for (int i = 0; i < matches.size(); i++)
	{
		// è·å–åŒ¹é…ç‚¹åœ¨å‰ä¸€å¼ å›¾åƒä¸­å¯¹åº”çš„ä¸‰ç»´ç©ºé—´ç‚¹çš„ç´¢å¼•
		int matched_world_point_indices = preImage.correspond_struct_idx[matches[i].queryIdx];

		// å¦‚æœåŒ¹é…ç‚¹åœ¨å‰ä¸€å¼ å›¾åƒä¸­å¯¹åº”çš„ä¸‰ç»´ç©ºé—´ç‚¹å­˜åœ¨
		if (matched_world_point_indices > 0)
		{
			// å°†å…¶ï¼ˆå‰ä¸€å¼ å›¾åƒä¸­çš„ä¸‰ç»´ç‚¹ï¼‰æ·»åŠ åˆ°object_pointsä¸­
			this->object_points.push_back(all_reconstructed_points[matched_world_point_indices]);

			// å°†åŒ¹é…ç‚¹ï¼ˆè¯¥æ–°å›¾åƒçš„äºŒç»´ç‚¹ï¼‰æ·»åŠ åˆ°image_pointsä¸­
			this->image_points.push_back(this->keyPoints[matches[i].trainIdx].pt);
		}
	}
}

```



## 3 å…·ä½“å®ç°

åœ¨å…ˆå‰çš„ä¸¤å¼ å›¾ç‰‡çš„åˆå§‹ä¸‰ç»´ç‚¹äº‘çš„æ„å»ºçš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬æ¥å®ç°å¤šå¼ å›¾çš„å¢é‡æ„å»º

### 3.1 åˆå§‹æ„å»º

åœ¨å‰é¢å‡ ç¯‡åšå®¢ä¸­å·²ç»è¯¦ç»†è®²è¿°è¿‡äº†ï¼šåŒ¹é…ï¼Œç”¨è®¡ç®— E çŸ©é˜µçš„æ–¹å¼æ±‚å¾—ç›¸æœºå¤–å‚ Rï¼ŒTï¼Œè¿›è¡Œä¸‰è§’åŒ–æ„å»ºç‚¹äº‘

ç‰¹åˆ«ï¼šä¸ºäº†åé¢çš„å¢å›¾é‡å»ºï¼Œæˆ‘ä»¬éœ€è¦<u>è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»</u>

```cpp
void initConstruction(vector<Images>& initImages, vector<Point3d>& all_reconstructed_points, vector<Vec3b>& all_points_colors)
{
    
    initImages.push_back(*(new Images(INIT_IMG_PATH1)));
    initImages.push_back(*(new Images(INIT_IMG_PATH2)));

    vector<DMatch> matches;
    initImages[0].matchFeatures(initImages[1], matches);

    vector<uchar> mask;
    Constructor::findCamera(K, initImages[0].matchedPoints, initImages[1].matchedPoints, initImages[1].R, initImages[1].T, mask);
    initImages[0].R = Mat::eye(3, 3, CV_64FC1);
    initImages[0].T = Mat::zeros(3, 1, CV_64FC1);
    all_reconstructed_points = Constructor::pointsReconstruct(K, initImages[0].R, initImages[0].T, initImages[1].R, initImages[1].T, initImages[0].matchedPoints, initImages[1].matchedPoints);
    
    initImages[1].findColor();
    for (int i = 0; i < initImages[1].colors.size(); i++)
    {
        all_points_colors.push_back(initImages[1].colors[i]);
    }


    // æ ¹æ®maskæ¥è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»
    int idx = 0;
    for (int i = 0; i < matches.size(); i++)
    {
        if (mask[i])
        {
            initImages[0].correspond_struct_idx[matches[i].queryIdx] = idx;
            initImages[1].correspond_struct_idx[matches[i].trainIdx] = idx;
            idx++;
        }
    }
}
```

### 3.2 å¢é‡æ„å»º

1. åˆ›å»º`subImageBag`ï¼Œç„¶åå°†`initImages[1]`æ·»åŠ åˆ°å®¹å™¨ä¸­ï¼Œå³è¡¨ç¤º`initImages`ä¸­çš„ç¬¬äºŒå¼ å›¾åƒï¼ˆæ•°ç»„ç´¢å¼•ä¸º1ï¼‰å°†ä¸åç»­è¿›è¡Œæ¯”è¾ƒï¼ˆå¦åˆ™ä¸‹ä¸€å¼ å›¾æ·»åŠ è¿›æ¥è·Ÿè°è¿›è¡ŒåŒ¹é…å‘¢ï¼‰

2. å¾ªç¯ï¼Œéå†`sub_image_paths`å®¹å™¨ä¸­çš„å›¾åƒæ–‡ä»¶è·¯å¾„

3. åœ¨å¾ªç¯ä¸­ï¼Œä¸ºæ¯ä¸ªå›¾åƒæ–‡ä»¶è·¯å¾„åˆ›å»ºä¸€ä¸ªæ–°çš„`Images`ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°`subImageBag`å®¹å™¨ä¸­ã€‚è¿™æ ·ï¼Œå®¹å™¨`subImageBag`ä¸­å°±åŒ…å«äº†å¤šå¼ å›¾åƒï¼Œå…¶ä¸­ç¬¬ä¸€å¼ å›¾åƒæ˜¯åˆå§‹å›¾åƒå¯¹çš„ç¬¬äºŒå¼ ï¼Œå…¶ä½™å›¾åƒæ˜¯é€æ­¥æ·»åŠ çš„

4. è°ƒç”¨`addImageConstruction`å‡½æ•°ï¼Œå°†`subImageBag`ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œä»¥åŠç”¨äºå­˜å‚¨ç¨€ç–ç‚¹äº‘çš„`all_reconstructed_points`å’Œç‚¹äº‘é¢œè‰²çš„`all_points_colors`

   - å¾ªç¯éå†`subImageBag`å®¹å™¨ä¸­çš„æ¯ä¸ªå›¾åƒï¼Œä»ç´¢å¼•1å¼€å§‹ï¼ˆå› ä¸ºç¬¬ä¸€ä¸ªå›¾åƒæ˜¯åˆå§‹å›¾åƒç”¨äºäº†åˆå§‹æ„å»ºï¼Œè·³è¿‡ï¼‰

   - å¯¹äºæ¯å¯¹ç›¸é‚»çš„å›¾åƒï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

     - ä½¿ç”¨`matchFeatures`æ–¹æ³•ï¼Œæ‰¾åˆ°ä¸¤ä¸ªç›¸é‚»å›¾åƒä¹‹é—´çš„ç‰¹å¾ç‚¹åŒ¹é…å…³ç³»ï¼Œå¹¶å°†åŒ¹é…ç»“æœå­˜å‚¨åœ¨`matches`å®¹å™¨ä¸­

     - ä½¿ç”¨`getObjPointsAndImgPoints`æ–¹æ³•ï¼Œè·å–åŒ¹é…çš„ç‰¹å¾ç‚¹å¯¹åº”çš„ä¸‰ç»´ç‚¹å’Œå›¾åƒç‚¹ â€”â€” ä¸º **PnP** åšå‡†å¤‡

     - é€šè¿‡**RANSAC**ç­›é€‰ï¼Œä½¿ç”¨`findCamera`æ–¹æ³•ç­›é€‰åŒ¹é…ç‚¹å¹¶ç”Ÿæˆä¸€ä¸ªmaskï¼Œç”¨äºæ ‡è®°æœ‰æ•ˆçš„åŒ¹é…ç‚¹ï¼ˆåªæ˜¯ä¸ºäº†ç­›é€‰ç½¢äº†ï¼‰

     - ä½¿ç”¨`solvePnPRansac`æ–¹æ³•ï¼Œä¼°è®¡æ–°å›¾åƒçš„ç›¸æœºä½å§¿ï¼Œè·å¾—Rï¼ŒT

     - è½¬æ¢æ—‹è½¬å‘é‡ä¸ºæ—‹è½¬çŸ©é˜µï¼ˆ`solvePnPRansac`å¾—åˆ°çš„æ˜¯ r å‘é‡ï¼‰

     - ä½¿ç”¨`pointsReconstruct`æ–¹æ³•ï¼Œé‡å»ºæ–°å›¾åƒä¸å‰å›¾åƒä¹‹é—´çš„ä¸‰ç»´ç‚¹ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨`new_restructure_points`ä¸­

     - ä½¿ç”¨`findColor`æ–¹æ³•ï¼Œè·å–æ–°å›¾åƒä¸­ç‚¹çš„é¢œè‰²ä¿¡æ¯

     - è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»ï¼š

       éå†`matches`ï¼Œæ ¹æ®`mask`ä¸­çš„æ ‡è®°ï¼Œå°†æ–°ç”Ÿæˆçš„ç‚¹ä¸åˆå§‹ä¸¤å¼ å›¾åƒçš„å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»è¿›è¡Œè®°å½•ï¼Œç»´æŠ¤ç‚¹ä¸ç‚¹äº‘ä¹‹é—´çš„å¯¹åº”å…³ç³»

     - æœ€åï¼Œå°†æ–°ç”Ÿæˆçš„ä¸‰ç»´ç‚¹`new_restructure_points`ä»¥åŠå®ƒä»¬çš„é¢œè‰²ä¿¡æ¯æ·»åŠ åˆ°`all_reconstructed_points`å’Œ`all_points_colors`ä¸­ï¼Œä¸æ–­æ‰©å±•ç‚¹äº‘

```cpp
void addImageConstruction(vector<Images>& subImageBag, vector<Point3d>& all_reconstructed_points, vector<Vec3b>& all_points_colors)
{
    for (int i = 1; i < subImageBag.size(); i++)
    {
        cout << i << endl;
        vector<DMatch> matches;
        subImageBag[i - 1].matchFeatures(subImageBag[i], matches);

        subImageBag[i].getObjPointsAndImgPoints(matches, all_reconstructed_points, subImageBag[i - 1]);

        // åªæ˜¯ä¸ºäº†è¿›è¡ŒRANSACç­›é€‰åŒ¹é…ç‚¹å’Œè·å–mask
        vector<uchar> mask;
        Mat discardR, discardT;
        Constructor::findCamera(K, subImageBag[i - 1].matchedPoints, subImageBag[i].matchedPoints, discardR, discardT, mask);


        solvePnPRansac(subImageBag[i].object_points, subImageBag[i].image_points, K, noArray(), subImageBag[i].R, subImageBag[i].T);
        Rodrigues(subImageBag[i].R, subImageBag[i].R);

        vector<Point3d> new_restructure_points;
        new_restructure_points = Constructor::pointsReconstruct(K, subImageBag[i - 1].R, subImageBag[i - 1].T, subImageBag[i].R, subImageBag[i].T, subImageBag[i - 1].matchedPoints, subImageBag[i].matchedPoints);

        subImageBag[i].findColor();

        // è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»
        int idx = 0;
        for (int k = 0; k < matches.size(); k++)
        {
            if (mask[k])
            {
                subImageBag[i - 1].correspond_struct_idx[matches[k].queryIdx] = all_reconstructed_points.size() + idx;
                subImageBag[i].correspond_struct_idx[matches[k].trainIdx] = all_reconstructed_points.size() + idx;
                idx++;
            }

        }
   
        for (int k = 0; k < new_restructure_points.size(); k++)
        {
            all_reconstructed_points.push_back(new_restructure_points[k]);
            all_points_colors.push_back(subImageBag[i].colors[k]);
        }
    }
}
```

### 3.3 å®Œæ•´main.cpp

```cpp
// å®šä¹‰å›¾åƒæ–‡ä»¶è·¯å¾„å’Œä¿å­˜ç»“æœçš„è·¯å¾„
//#define INIT_IMG_PATH1 "test_img\\images\\100_7103.jpg"
//#define INIT_IMG_PATH2 "test_img\\images\\100_7104.jpg"
#define INIT_IMG_PATH1 "test_img\\First stage\\B25.jpg"
#define INIT_IMG_PATH2 "test_img\\First stage\\B24.jpg"
#define PLY_SAVE_PATH "test_img\\results\\output.ply"

#include "Includes.h"
#include "Images.h"
#include "Constructor.h"

//const Mat K = (Mat_<double>(3, 3) << 2905.88, 0, 1416, 0, 2905.88, 1064, 0, 0, 1);
const Mat K = (Mat_<double>(3, 3) << 719.5459, 0, 0, 0, 719.5459, 0, 0, 0, 1);

//const vector<string> sub_image_paths = { /*"test_img\\images\\100_7100.jpg", "test_img\\images\\100_7101.jpg", "test_img\\images\\100_7102.jpg",*/ /*"test_img\\images\\100_7103.jpg", "test_img\\images\\100_7104.jpg",*/ "test_img\\images\\100_7105.jpg", "test_img\\images\\100_7106.jpg", "test_img\\images\\100_7107.jpg", "test_img\\images\\100_7108.jpg", "test_img\\images\\100_7109.jpg"/*, "test_img\\images\\100_7110.jpg"*/ };


const vector<string> sub_image_paths = { "test_img\\First stage\\B23.jpg", "test_img\\First stage\\B22.jpg", "test_img\\First stage\\B21.jpg" };
void initConstruction(vector<Images>& initImages, vector<Point3d>& all_reconstructed_points, vector<Vec3b>& all_points_colors)
{
    
    initImages.push_back(*(new Images(INIT_IMG_PATH1)));
    initImages.push_back(*(new Images(INIT_IMG_PATH2)));

    vector<DMatch> matches;
    initImages[0].matchFeatures(initImages[1], matches);

    vector<uchar> mask;
    Constructor::findCamera(K, initImages[0].matchedPoints, initImages[1].matchedPoints, initImages[1].R, initImages[1].T, mask);
    initImages[0].R = Mat::eye(3, 3, CV_64FC1);
    initImages[0].T = Mat::zeros(3, 1, CV_64FC1);
    all_reconstructed_points = Constructor::pointsReconstruct(K, initImages[0].R, initImages[0].T, initImages[1].R, initImages[1].T, initImages[0].matchedPoints, initImages[1].matchedPoints);
    
    initImages[1].findColor();
    for (int i = 0; i < initImages[1].colors.size(); i++)
    {
        all_points_colors.push_back(initImages[1].colors[i]);
    }


    // æ ¹æ®maskæ¥è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»
    int idx = 0;
    for (int i = 0; i < matches.size(); i++)
    {
        if (mask[i])
        {
            initImages[0].correspond_struct_idx[matches[i].queryIdx] = idx;
            initImages[1].correspond_struct_idx[matches[i].trainIdx] = idx;
            idx++;
        }
    }
}

void addImageConstruction(vector<Images>& subImageBag, vector<Point3d>& all_reconstructed_points, vector<Vec3b>& all_points_colors)
{
    for (int i = 1; i < subImageBag.size(); i++)
    {
        cout << i << endl;
        vector<DMatch> matches;
        subImageBag[i - 1].matchFeatures(subImageBag[i], matches);

        subImageBag[i].getObjPointsAndImgPoints(matches, all_reconstructed_points, subImageBag[i - 1]);

        // åªæ˜¯ä¸ºäº†è¿›è¡ŒRANSACç­›é€‰åŒ¹é…ç‚¹å’Œè·å–mask
        vector<uchar> mask;
        Mat discardR, discardT;
        Constructor::findCamera(K, subImageBag[i - 1].matchedPoints, subImageBag[i].matchedPoints, discardR, discardT, mask);


        solvePnPRansac(subImageBag[i].object_points, subImageBag[i].image_points, K, noArray(), subImageBag[i].R, subImageBag[i].T);
        Rodrigues(subImageBag[i].R, subImageBag[i].R);

        vector<Point3d> new_restructure_points;
        new_restructure_points = Constructor::pointsReconstruct(K, subImageBag[i - 1].R, subImageBag[i - 1].T, subImageBag[i].R, subImageBag[i].T, subImageBag[i - 1].matchedPoints, subImageBag[i].matchedPoints);

        subImageBag[i].findColor();

        // è®°å½•åˆå§‹ä¸¤å¼ å›¾å„ä¸ªç‚¹å’Œç‚¹äº‘çš„å…³ç³»
        int idx = 0;
        for (int k = 0; k < matches.size(); k++)
        {
            if (mask[k])
            {
                subImageBag[i - 1].correspond_struct_idx[matches[k].queryIdx] = all_reconstructed_points.size() + idx;
                subImageBag[i].correspond_struct_idx[matches[k].trainIdx] = all_reconstructed_points.size() + idx;
                idx++;
            }

        }


       

        for (int k = 0; k < new_restructure_points.size(); k++)
        {
            all_reconstructed_points.push_back(new_restructure_points[k]);
            all_points_colors.push_back(subImageBag[i].colors[k]);
        }
    }

}

int main()
{
    try
    {
        vector<Images> initImages;
        vector<Point3d> all_reconstructed_points;
        vector<Vec3b> all_points_colors;

        initConstruction(initImages, all_reconstructed_points, all_points_colors);

        vector<Images> subImageBag;
        subImageBag.push_back(initImages[1]);
        for (auto& image_path : sub_image_paths)
        {
            subImageBag.push_back(Images(image_path));
        }

        addImageConstruction(subImageBag, all_reconstructed_points, all_points_colors);        
        
        // æ‰‹åŠ¨è¾“å‡ºç‚¹äº‘plyæ–‡ä»¶
        std::ofstream plyFile(PLY_SAVE_PATH);

        // plyçš„å¤´éƒ¨ä¿¡æ¯
        plyFile << "ply\n";
        plyFile << "format ascii 1.0\n";
        plyFile << "element vertex " << all_reconstructed_points.size() << "\n";
        plyFile << "property float x\n";
        plyFile << "property float y\n";
        plyFile << "property float z\n";
        plyFile << "property uchar blue\n";
        plyFile << "property uchar green\n";
        plyFile << "property uchar red\n";
        plyFile << "end_header\n";

        // å†™å…¥ç‚¹äº‘æ•°æ®
        for (int i = 0; i < all_reconstructed_points.size(); ++i)
        {
            cv::Vec3b color = all_points_colors[i];
            cv::Point3f point = all_reconstructed_points[i];
            plyFile << point.x << " " << point.y << " " << point.z << " "
                << static_cast<int>(color[0]) << " "
                << static_cast<int>(color[1]) << " "
                << static_cast<int>(color[2]) << std::endl;
        }

        plyFile.close();
        return 0;
    }
    catch (Exception e)
    {
        cout << e.msg << endl;
    }
    
}
```

## 4 æ€»ç»“æ³¨æ„

> ==æºç == å³ä¸Šé¢ç»™å‡ºçš„ Include.hï¼ŒConstructor.hï¼ŒConstructor.cppï¼ŒImage.hï¼ŒImage.cppï¼Œmain.cpp

å¢é‡åŠ å›¾å‰ï¼ˆä¸¤å¼ åˆå§‹å›¾çš„æ„å»ºï¼‰ï¼š

![image-20231020200930233](https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-10-20/image-20231020200930233.png)

å¢é‡åŠ å›¾æ„é€ åï¼š

![image-20231020200946321](https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-10-20/image-20231020200946321.png)

==**æ³¨æ„**==ï¼š

ç›®å‰åªæ˜¯å®Œæˆäº†åŸºæœ¬æµç¨‹ï¼Œæœ‰å¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦ä¼˜åŒ–ï¼Œæ¯”å¦‚

-  **SIFT** çš„å‚æ•°è®¾ç½®
- **RANSAC** çš„å‚æ•°è®¾ç½®
- **åˆå§‹å›¾ç‰‡**çš„é€‰æ‹©ï¼ˆå¾ˆé‡è¦ï¼‰
- `matchFeatures` ä¸­çš„ **ratio test** çš„è®¾ç½®
- è¿˜å¯ä»¥å¢åŠ å…¶ä»–ä¼˜åŒ–æªæ–½æ¥å‰”é™¤ç¦»è°±ç‚¹
- æœ€é‡è¦çš„ **BA** è¿˜æ²¡æœ‰åŠ å…¥ï¼
- Â·Â·Â·Â·Â·Â·Â·

> ç›®å‰ï¼Œå‡ºæ¥çš„æ•ˆæœä¸å¥½ï¼Œé©å‘½å°šæœªæˆåŠŸï¼ŒåŒå¿—è¿˜éœ€åŠªåŠ›ï¼ğŸ˜­ğŸ˜­ğŸ˜­

å‚è€ƒèµ„æ–™ï¼š

[åŸºäºOpenCVå’ŒC++çš„å¤šè§†å›¾ä¸‰ç»´é‡å»º](https://zhuanlan.zhihu.com/p/339543713)
[OpenCVå®ç°SfMï¼ˆä¸‰ï¼‰ï¼šå¤šç›®ä¸‰ç»´é‡å»º](https://blog.csdn.net/gaotihong/article/details/79075256)
