---
title:  5 Linux&Server
createTime: 2025/04/20 14:35:03
permalink: /experience/yfhmgv8g/
---
## 5.1 Terminal / Tmux

### 5.1.1 bash/zsh

**卡死**：

- zsh 卡死：可以连 vscode 转换 bash 连来看是否是都卡死了
- 都卡死：可以连 vscode，使用 ipynb 运行命令/脚本

**脚本 `.sh`：**

1. **`sh` 命令**：
   - 通常是指向 `sh` 的符号链接。
   - 在许多现代 Linux 系统中，`sh` 实际上是 `dash`，而不是 `bash`。
   - `dash` 是一个更轻量级的 shell，支持的语法比 `bash` 少，可能会导致脚本中使用的某些 `bash` 特性无法运行。
2. **`bash` 命令**：
   - 明确使用 `bash` 解释器运行脚本。
   - 支持完整的 `bash` 语法和特性。
3. **`./run.sh`**：
   - 使用脚本文件中指定的 Shebang（第一行 `#!/bin/bash`）来运行脚本。
   - 如果脚本的 Shebang 是 `#!/bin/bash`，那么它会使用 `bash` 解释器。

### 5.1.2 Tmux

[https://github.com/samoshkin/tmux-config](https://github.com/samoshkin/tmux-config)

`F12` 是锁定，此时 Tmux 所有的快捷键都被锁定，再按 `F12` 解锁

`Ctrl+A` `/` ：缓冲区搜索，输入要搜索的字符串，然后按 `Enter`，按 `n` 再次搜索相同的字符串，按 `Shift- n` 进行反向搜索

### 5.1.3 实用工具

[https://pengsida.notion.site/59569d7b66954578b21bf1dc6ea35776](https://pengsida.notion.site/59569d7b66954578b21bf1dc6ea35776)

- ncdu： 查看文件夹占用

- fzf：安装如下

  ```bash
  git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf 
  ~/.fzf/install
  
  cd ~/.fzf && git pull && ./install # upgrade
  ```

  使用：Ctrl+R 用来在历史中搜索，Ctrl+T 用来搜索当前文件夹下的内容

- ctop：监控每个docker 容器的资源使用情况（需要sudo）

- [gg](https://github.com/mzz2017/gg)：支持节点与订阅链接的 Linux 命令行代理工具

- yazi：基于异步 I/O 的超快终端文件管理器

## 5.2 SSH

### 5.2.1 端口转发

这是通过 `ssh` 进行端口转发的一个例子，具体来说是 **本地端口转发**：

```bash
ssh -L 8001:localhost:8001 usrname@serverip
```

1. `-L`：
   - 这是指定进行本地端口转发的选项。也就是说，要将本地机器的一个端口通过 SSH 隧道转发到远程服务器上的某个服务。
2. `8001:localhost:8001`：
   - 第一个 `8001`：表示本地计算机上的端口，意味着当在本地访问 `localhost:8001` 时，流量会被转发到远程服务器上
   - `localhost`：这是远程服务器上的地址，指向的是该服务器的本地（本机）网络。通常这代表希望访问远程服务器上的某个本地服务
   - 第二个 `8001`：这是远程服务器上的端口，意味着希望将本地的流量通过 SSH 隧道转发到远程服务器的 `localhost:8001`
3. `usrname@server_ip`：
   - `usrname` 在远程服务器上的用户名
   - `serverip` 要连接的远程服务器的 IP 地址或主机名

例子：

```bash
ssh -L 8001:localhost:8001 zjucad3090
...
tensorboard --logdir=xxx --port=8001
```

通过这样就可以在本地浏览器打开服务器 events.out.tfevents 文件

总结：通过 SSH 隧道将本地机器上的端口 8001 转发到远程服务器上同样的端口 8001。换句话说，在本地访问 `localhost:8001` 时，流量会通过 SSH 安全通道被发送到远程服务器上，然后该流量会被转发到远程服务器的 `localhost:8001` 上的服务。

## 5.3 进程

### 5.3.1 垃圾进程

[https://blog.csdn.net/qq_43619271/article/details/138166254](https://blog.csdn.net/qq_43619271/article/details/138166254)

[https://zhuanlan.zhihu.com/p/506686899](https://zhuanlan.zhihu.com/p/506686899)

**解决方法零**

Kill Process 后依然占用显存并显示 No Such Process

查找僵尸进程：

```bash
ps aux | grep 'Z' # 僵尸进程（状态为 `Z` 或 `Zl`）
```

1. 确认僵尸进程的父进程

   ```bash
   ps -o ppid= -p <僵尸进程PID>
   ```

2. 终止父进程：找到父进程后，终止它：

   ```bash
   kill -9 <父进程PID>
   ```

------

**解决方法一**

1. 使用 `fuser` 查找占用显卡资源的进程

   - 命令可以查看哪些进程正在使用 GPU 设备。命令如下：

     ```bash
     fuser -v /dev/nvidia*
     ```

     这会列出所有正在占用显卡资源的进程及其相关信息。

2. **确认占用 GPU 的进程**

   - 查找进程信息：通过 `fuser` 找到进程号（PID）后，可以使用以下命令查看进程的详细信息：

     ```bash
     ps -ef | grep <PID>
     ```

     这样可以确认是否是想要的程序

3. **强制终止进程**

   - 如果确认进程是相关程序，强制终止进程：

     ```bash
     kill -9 <PID>
     ```

**解决方法二**

所以如果知道 No Such Process 对应的 command 中有什么独特的字段的话，比如 No Such Process 原本的 command 中，有一段独有的字段 `mixed`，那么就可以通过指令

```bash
ps aux | grep mixed | grep -v grep | awk '{print $2}' | xargs kill
```

借助这个 command，可以终止所有与“mixed”相关的进程

1. **`ps aux`**:
   - `ps` 命令用于列出当前系统上所有的进程。`aux` 是选项，表示：
     - `a`: 显示所有用户的进程，不仅仅是当前用户的进程（最好不加）
     - `u`: 以用户为中心显示进程
     - `x`: 显示没有控制终端的进程
2. **`grep mixed`**:
   - `grep` 是用来过滤文本内容的命令。这里它的作用是查找包含 "mixed" 字符串的进程信息
3. **`grep -v grep`**:
   - `grep -v grep` 这个部分是排除掉包含“grep”字符串的行。因为上一条命令中也会出现包含“grep mixed”的进程，这会导致我们匹配到自己当前执行的 `grep` 命令，所以用 `-v` 来排除掉这一行
4. **`awk '{print $2}'`**:
   - `awk` 是一个文本处理工具，`'{print $2}'` 表示输出每一行的第二列，这一列通常是进程的 PID
5. **`xargs kill`**:
   - `xargs` 会将从前面命令传递过来的 PID 列表作为参数传递给 `kill` 命令
   - `kill` 命令根据传入的 PID 来终止对应的进程

**特殊：**

查看僵尸进程的父进程 ID（PPID）：

```bash
ps -o ppid= -p <僵尸进程PID>
```

- 如果 PPID 是 `1`（`init` 或 `systemd`），说明父进程是系统级别的进程
- 如果 PPID 不存在，说明父进程已经退出

如果父进程是 `init` 或 `systemd`，通常系统会自动回收这些僵尸进程。如果它们仍然存在，可以尝试以下方法：

1. **重启系统**：重启系统是最简单的方法，可以彻底清理所有僵尸进程

2. **手动触发系统回收**：如果不想重启系统，可以尝试重新启动 `systemd` 或 `init`：

   ```bash
   sudo systemctl daemon-reload
   ```

**批量清理僵尸进程**

如果有多个僵尸进程，可以编写一个简单的脚本来批量清理它们：

```bash
for pid in $(ps aux | grep 'Z' | awk '{print $2}'); do
  ppid=$(ps -o ppid= -p $pid)
  echo "Killing parent process $ppid of zombie process $pid"
  kill -9 $ppid
done
```

这个脚本会找到所有僵尸进程并终止它们的父进程。（但是如果父进程是 `1` 就不行）

