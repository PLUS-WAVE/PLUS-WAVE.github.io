---
title: OpenCVä¸¤å¼ å›¾ç‰‡å®ç°ç¨€ç–ç‚¹äº‘çš„ç”Ÿæˆ
tags: 
  - 3DVision
  - OpenCV
  - SfM
createTime: 2023/09/25 16:30:25
permalink: /article/11ohv0jz/
cover: https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-09-25/image-20230925090905231.png
---


ğŸŒŸåç»­çš„å®Œæˆçš„é¡¹ç›®ï¼šWindows ä¸ŠåŸºäº OpenMVG + OpenMVS çš„3Dé‡å»ºå¹³å° â€”â€” **[ğŸŒŠWAVE-3D-Reconstruction](https://github.com/PLUS-WAVE/WAVE-3D-Reconstruction)**
## 1 EçŸ©é˜µ

### 1.1 ç”±Fåˆ°E

$$
E = K^T * F * K 
$$

E çŸ©é˜µå¯ä»¥ç›´æ¥é€šè¿‡ä¹‹å‰ç®—å¥½çš„ F çŸ©é˜µä¸ç›¸æœºå†…å‚ K çŸ©é˜µè·å¾—
<!-- more -->
```cpp
Mat E = K.t() * F * K;
```


> ç›¸æœºå†…å‚è·å¾—çš„æ–¹å¼æ˜¯ä¸€ä¸ªè¾ƒä¸ºå¤æ‚çš„æ–¹å¼ï¼Œéœ€è¦ä½¿ç”¨æ£‹ç›˜è¿›è¡Œå®šä½è·å¾—ï¼Œæˆ‘ä»¬è¿™é‡Œç›´æ¥ä½¿ç”¨äº† [OpenMVG](https://github.com/openMVG/ImageDataset_SceauxCastle) æä¾›çš„ç°æˆçš„å›¾ç‰‡å’Œ K çŸ©é˜µ



### 1.2 ç›´æ¥ä½¿ç”¨å‡½æ•°

åˆ©ç”¨ openCV æä¾›çš„ `findEssentialMat` å‡½æ•°å¯ä»¥ç›´æ¥å¾—åˆ° E çŸ©é˜µ

```cpp
Mat E = findEssentialMat(matchedPoints1, matchedPoints2, K, RANSAC, 0.999, 1.0, inliers);
```

## 2 ç›¸æœºå§¿æ€æ¢å¤

è¿™ä¸€æ­¥å¯ä»¥ä½¿ç”¨ **SVD** æ¥é€šè¿‡ E çŸ©é˜µè·å–ç›¸å¯¹<u>æ—‹è½¬çŸ©é˜µ R</u> å’Œ<u>å¹³ç§»å‘é‡ t</u> 

ä½†æ˜¯OpenCVç›´æ¥æä¾›äº†ä¸€ä¸ªéå¸¸ä¾¿æ·çš„å‡½æ•° â€”â€” `recoverPose`

å…¶æ¥å—æœ¬è´¨çŸ©é˜µ E ã€ç‰¹å¾ç‚¹çš„å¯¹åº”å…³ç³»ã€ç›¸æœºçš„å†…å‚ä¿¡æ¯ä»¥åŠè¾“å‡ºçš„ç›¸å¯¹æ—‹è½¬çŸ©é˜µ `R` å’Œå¹³ç§»å‘é‡ `t` ï¼›å®ƒä¼šè‡ªåŠ¨è¿›è¡Œ SVD åˆ†è§£å’Œå…¶ä»–å¿…è¦çš„è®¡ç®—ï¼Œä»¥æ¢å¤ç›¸å¯¹å§¿æ€ä¿¡æ¯

```cpp
 //ç›¸æœºå§¿æ€æ¢å¤ï¼Œæ±‚è§£R,t,æŠ•å½±çŸ©é˜µ
 Mat R, t;
 recoverPose(E, inlierPoints1, inlierPoints2, K, R, t);
```

## 3 ç›¸æœºæŠ•å½±çŸ©é˜µ

è¦æ„å»ºç›¸æœºçš„æŠ•å½±çŸ©é˜µï¼ˆä¹Ÿç§°ä¸ºè§†å›¾çŸ©é˜µæˆ–å¤–å‚çŸ©é˜µï¼‰ï¼Œéœ€è¦å°†æ—‹è½¬çŸ©é˜µ `R` å’Œå¹³ç§»å‘é‡ `t` åˆå¹¶åˆ°ä¸€èµ·ï¼ŒæŠ•å½±çŸ©é˜µé€šå¸¸è¡¨ç¤ºä¸º 3x4 çš„çŸ©é˜µï¼Œå…¶ä¸­æ—‹è½¬çŸ©é˜µå’Œå¹³ç§»å‘é‡éƒ½ä½äºå…¶ä¸­çš„é€‚å½“ä½ç½®

é€šå¸¸æƒ…å†µä¸‹ï¼ŒæŠ•å½±çŸ©é˜µçš„å½¢å¼å¦‚ä¸‹ï¼š


$$
P_1 = K * [R | t]
$$

$$
P_2 = K * [I | 0]
$$

å®ç°ä»£ç å¦‚ä¸‹ï¼š

```cpp
// åˆ›å»ºä¸¤ä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µ [R T]
Mat proj1(3, 4, CV_32FC1);
Mat proj2(3, 4, CV_32FC1);

// è®¾ç½®ç¬¬ä¸€ä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µä¸ºå•ä½çŸ©é˜µ [I | 0]
proj1(Range(0, 3), Range(0, 3)) = Mat::eye(3, 3, CV_32FC1);
proj1.col(3) = Mat::zeros(3, 1, CV_32FC1);

// è®¾ç½®ç¬¬äºŒä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µä¸ºè¾“å…¥çš„æ—‹è½¬çŸ©é˜µ R å’Œå¹³ç§»å‘é‡ T
R.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_32FC1);
t.convertTo(proj2.col(3), CV_32FC1);

// è½¬æ¢ç›¸æœºå†…å‚çŸ©é˜µ K ä¸ºæµ®ç‚¹å‹
Mat fK;
K.convertTo(fK, CV_32FC1);

// è®¡ç®—æŠ•å½±çŸ©é˜µ [K * [R|T]]
proj1 = fK * proj1;
proj2 = fK * proj2;
```

## 4 ä¸‰è§’æ³•å¾—ç¨€ç–ç‚¹äº‘

### 4.1 ä¸‰è§’æ³•è®¡ç®—3Dç‚¹

å¯¹äºæ¯å¯¹åŒ¹é…çš„ç‰¹å¾ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ä¸‰è§’æ³•æ¥è®¡ç®—å®ƒä»¬çš„ä¸‰ç»´åæ ‡ï¼›è¿™é€šå¸¸æ¶‰åŠåˆ°å°†ä¸¤ä¸ªè§†è§’ä¸‹çš„åƒç´ åæ ‡ä¸ç›¸åº”çš„æŠ•å½±çŸ©é˜µç›¸ç»“åˆï¼Œä»¥æ¢å¤ä¸‰ç»´åæ ‡

```cpp
// ä¸‰è§’æ³•æ±‚è§£ç¨€ç–ä¸‰ç»´ç‚¹äº‘
Mat point4D_homogeneous(4, inlierPoints1.size(), CV_64F);
triangulatePoints(proj1, proj2, inlierPoints1, inlierPoints2, point4D_homogeneous);
```

### 4.2 è½¬æ¢ä¸ºéé½æ¬¡åæ ‡

å‡½æ•° `triangulatePoints` å¾—åˆ°çš„ `point4D_homogeneous` é€šå¸¸æ˜¯é½æ¬¡åæ ‡ï¼Œéœ€è¦å°†å®ƒä»¬è½¬æ¢ä¸ºéé½æ¬¡åæ ‡ï¼Œä»¥å¾—åˆ°çœŸå®çš„ä¸‰ç»´ç‚¹åæ ‡

```cpp
// å°†é½æ¬¡åæ ‡è½¬æ¢ä¸ºä¸‰ç»´åæ ‡
Mat point3D;
convertPointsFromHomogeneous(point4D_homogeneous.t(), point3D);
cout << point3D << endl;
```

## 5 åŒ¹é…é¢œè‰²

å°†é¢œè‰²ä¿¡æ¯ä¸ç‚¹äº‘å…³è”åœ¨ä¸€èµ·

ä½¿ç”¨äº†å†…ç‚¹ï¼ˆinliersï¼‰çš„åæ ‡ä»å›¾åƒä¸­æå–äº†é¢œè‰²ä¿¡æ¯ï¼Œç„¶åå°†é¢œè‰²ä¿¡æ¯ä¸ä¸‰ç»´ç‚¹åæ ‡å…³è”èµ·æ¥ï¼Œç”Ÿæˆäº†å¸¦æœ‰é¢œè‰²çš„ç¨€ç–ç‚¹äº‘

å¹¶å°†å…¶å­˜å‚¨åœ¨ `pointCloud` å’Œ `pointColors` ä¸­ï¼›å°±å¯ä»¥æ ¹æ®éœ€è¦è¿›ä¸€æ­¥å¤„ç†é¢œè‰²ä¿¡æ¯

```cpp
 // è·å–ç‰¹å¾ç‚¹çš„é¢œè‰²ä¿¡æ¯
 vector<Vec3b> colors1, colors2; // é¢œè‰²ä¿¡æ¯

 for (Point2f& inlierPoints : inlierPoints1)
 {
     int x = cvRound(inlierPoints.x); // å…³é”®ç‚¹çš„xåæ ‡
     int y = cvRound(inlierPoints.y); // å…³é”®ç‚¹çš„yåæ ‡
     Vec3b color = img1.at<Vec3b>(y, x);
     colors1.push_back(color);
 }

 for (Point2f& inlierPoints : inlierPoints2)
 {
     int x = cvRound(inlierPoints.x); // å…³é”®ç‚¹çš„xåæ ‡
     int y = cvRound(inlierPoints.y); // å…³é”®ç‚¹çš„yåæ ‡
     Vec3b color = img2.at<Vec3b>(y, x);
     colors2.push_back(color);
 }

 // åˆ›å»ºå¸¦é¢œè‰²çš„ç‚¹äº‘æ•°æ®ç»“æ„
 vector<Point3f> pointCloud;
 vector<Vec3b> pointColors;

 // å…³è”é¢œè‰²ä¿¡æ¯åˆ°ç‚¹äº‘
 for (int i = 0; i < point3D.rows; ++i)
 {
     Point3f point = point3D.at<Point3f>(i);
     Vec3b color1 = colors1[i];
     Vec3b color2 = colors2[i];

     // åœ¨è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©ä½¿ç”¨å“ªä¸ªé¢œè‰²ï¼Œæˆ–è€…è¿›è¡Œé¢œè‰²æ’å€¼ç­‰å¤„ç†
     Vec3b finalColor = color1; // è¿™é‡Œç¤ºä¾‹ä½¿ç”¨ç¬¬ä¸€ä¸ªç›¸æœºçš„é¢œè‰²

     pointCloud.push_back(point);
     pointColors.push_back(finalColor);
 }
```

## 6 ç”Ÿæˆ ply æ–‡ä»¶

æ‰‹åŠ¨è¾“å‡ºç‚¹äº‘ PLY æ–‡ä»¶ï¼Œå¹¶åŒ…æ‹¬äº† PLY æ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯ä»¥åŠç‚¹äº‘æ•°æ®çš„å†™å…¥ï¼›è¿™æ˜¯ä¸€ç§åˆ›å»ºåŒ…å«é¢œè‰²ä¿¡æ¯çš„ PLY æ–‡ä»¶çš„æœ‰æ•ˆæ–¹æ³•

åœ¨ PLY æ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯ä¸­ï¼ŒæŒ‡å®šäº†ç‚¹çš„æ•°é‡ä»¥åŠç‚¹çš„å±æ€§ï¼ŒåŒ…æ‹¬ç‚¹çš„åæ ‡å’Œé¢œè‰²é€šé“ï¼ˆè“è‰²ã€ç»¿è‰²ã€çº¢è‰²ï¼‰ç„¶åï¼Œä½ å¾ªç¯éå†ç‚¹äº‘æ•°æ®ï¼Œå°†ç‚¹çš„åæ ‡å’Œé¢œè‰²ä¿¡æ¯å†™å…¥PLYæ–‡ä»¶

å…¶ä¼šç”Ÿæˆä¸€ä¸ªåŒ…å«ç‚¹äº‘å’Œé¢œè‰²ä¿¡æ¯çš„PLYæ–‡ä»¶ï¼Œå¯ä»¥å°†å…¶ç”¨äºä¿å­˜ç‚¹äº‘ä»¥è¿›è¡Œå¯è§†åŒ–æˆ–è¿›ä¸€æ­¥å¤„ç†

> ç‰¹åˆ«æ³¨æ„ï¼šå›¾ç‰‡æ˜¯RGBè¿˜æ˜¯BGRçš„é¢œè‰²é€šé“ï¼Œè¿™é‡Œæ˜¯RGB
>
> `color[0]`ï¼Œ`color[1]` ï¼Œ`color[2]` åˆ†åˆ«ä»£è¡¨è“è‰²ï¼Œç»¿è‰²ï¼Œçº¢è‰²é€šé“

```cpp
// æ‰‹åŠ¨è¾“å‡ºç‚¹äº‘plyæ–‡ä»¶
ofstream plyFile(PLY_SAVE_PATH);

// plyçš„å¤´éƒ¨ä¿¡æ¯
plyFile << "ply\n";
plyFile << "format ascii 1.0\n";
plyFile << "element vertex " << point3D.rows << "\n";
plyFile << "property float x\n";
plyFile << "property float y\n";
plyFile << "property float z\n";
plyFile << "property uchar blue\n";
plyFile << "property uchar green\n";
plyFile << "property uchar red\n";
plyFile << "end_header\n";

// å†™å…¥ç‚¹äº‘æ•°æ®
for (int i = 0; i < point3D.rows; ++i)
{
    Vec3b color = pointColors[i];
    const float* point = point3D.ptr<float>(i);
    plyFile << point[0] << " " << point[1] << " " << point[2] << " "
            << static_cast<int>(color[0]) << " "
            << static_cast<int>(color[1]) << " "
            << static_cast<int>(color[2]) << endl;
}

plyFile.close();   
```

## 7 å®Œæ•´æµ‹è¯•ä»£ç 

> å…³äºä¹‹å‰çš„é˜¶æ®µå¯ä»¥æŸ¥çœ‹æˆ‘ä¹‹å‰çš„æ–‡ç« 

```cpp
// å®šä¹‰å›¾åƒæ–‡ä»¶è·¯å¾„å’Œä¿å­˜ç»“æœçš„è·¯å¾„
#define IMG_PATH1 "test_img\\images\\100_7105.jpg"
#define IMG_PATH2 "test_img\\images\\100_7106.jpg"
#define PLY_SAVE_PATH "test_img\\results\\output.ply"
#define K_NUM 2905.88, 0, 1416, 0, 2905.88, 1064, 0, 0, 1 // 3*3

#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <fstream>

using namespace std;
using namespace cv;

int main()
{
    // é˜¶æ®µä¸€------------------------------------------------------------------------------------
    // è¯»å–ä¸¤å¹…å›¾åƒ
    Mat img1 = imread(IMG_PATH1);
    Mat img2 = imread(IMG_PATH2);
    if (img1.empty() || img2.empty())
    {
        cout << "æ— æ³•è¯»å–å›¾åƒ" << endl;
        return -1;
    }

    // åˆ›å»ºSIFTå¯¹è±¡
    Ptr<SIFT> sift = SIFT::create();
    vector<KeyPoint> keypoints1, keypoints2;
    Mat descriptors1, descriptors2;

    // æ£€æµ‹å…³é”®ç‚¹å¹¶è®¡ç®—æè¿°å­
    sift->detectAndCompute(img1, noArray(), keypoints1, descriptors1);
    sift->detectAndCompute(img2, noArray(), keypoints2, descriptors2);

    // ä½¿ç”¨FLANNè¿›è¡Œç‰¹å¾åŒ¹é…
    FlannBasedMatcher matcher;
    vector<vector<DMatch>> matches;
    matcher.knnMatch(descriptors1, descriptors2, matches, 2);
    vector<DMatch> good_matches;
    for (int i = 0; i < matches.size(); ++i)
    {
        const float ratio = 0.7f;
        if (matches[i][0].distance < ratio * matches[i][1].distance)
        {
            good_matches.push_back(matches[i][0]);
        }
    }
    
    
    // é˜¶æ®µäºŒ------------------------------------------------------------------------------------
    // å£°æ˜ç”¨äºä¿å­˜åŒ¹é…ç‚¹å¯¹çš„å®¹å™¨
    vector<Point2f> matchedPoints1, matchedPoints2;

    for (int i = 0; i < good_matches.size(); ++i)
    {
        matchedPoints1.push_back(keypoints1[good_matches[i].queryIdx].pt);
        matchedPoints2.push_back(keypoints2[good_matches[i].trainIdx].pt);
    }
    

    // è¿›è¡ŒåŸºæœ¬çŸ©é˜µFçš„ä¼°è®¡å¹¶ä½¿ç”¨RANSACç­›é€‰
    Mat F;
    vector<uchar> inliers;
    F = findFundamentalMat(matchedPoints1, matchedPoints2, inliers, FM_RANSAC);
    cout << F << endl;

    vector<Point2f> inlierPoints1;
    vector<Point2f> inlierPoints2;
    for (int i = 0; i < inliers.size(); ++i)
    {
        if (inliers[i])
        {
			inlierPoints1.push_back(matchedPoints1[i]);
			inlierPoints2.push_back(matchedPoints2[i]);
		}
	}

    // ç›¸æœºå†…å‚çŸ©é˜µK
    Mat K = (Mat_<double>(3, 3) << K_NUM);
    cout << K << endl;

    ////è®¡ç®—æœ¬è´¨çŸ©é˜µE
    //Mat E = findEssentialMat(matchedPoints1, matchedPoints2, K, RANSAC, 0.999, 1.0, inliers);
    Mat E = K.t() * F * K;
    cout << "Essential Matrix (E):" << endl;
    cout << E << endl;
    
    //ç›¸æœºå§¿æ€æ¢å¤ï¼Œæ±‚è§£R,t,æŠ•å½±çŸ©é˜µ
    Mat R, t;
    recoverPose(E, inlierPoints1, inlierPoints2, K, R, t);
    cout << "recoverpose" << endl;
    cout << "R:" << R << endl;
    cout << "t:" << t << endl;
    
    // åˆ›å»ºä¸¤ä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µ [R T]
    Mat proj1(3, 4, CV_32FC1);
    Mat proj2(3, 4, CV_32FC1);
    
    // è®¾ç½®ç¬¬ä¸€ä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µä¸ºå•ä½çŸ©é˜µ [I | 0]
    proj1(Range(0, 3), Range(0, 3)) = Mat::eye(3, 3, CV_32FC1);
    proj1.col(3) = Mat::zeros(3, 1, CV_32FC1);
    
    // è®¾ç½®ç¬¬äºŒä¸ªç›¸æœºçš„æŠ•å½±çŸ©é˜µä¸ºè¾“å…¥çš„æ—‹è½¬çŸ©é˜µ R å’Œå¹³ç§»å‘é‡ T
    R.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_32FC1);
    t.convertTo(proj2.col(3), CV_32FC1);
    
    // è½¬æ¢ç›¸æœºå†…å‚çŸ©é˜µ K ä¸ºæµ®ç‚¹å‹
    Mat fK;
    K.convertTo(fK, CV_32FC1);
    
    // è®¡ç®—æŠ•å½±çŸ©é˜µ [K * [R|T]]
    proj1 = fK * proj1;
    proj2 = fK * proj2;
    
    // ä¸‰è§’æ³•æ±‚è§£ç¨€ç–ä¸‰ç»´ç‚¹äº‘
    Mat point4D_homogeneous(4, inlierPoints1.size(), CV_64F);
    triangulatePoints(proj1, proj2, inlierPoints1, inlierPoints2, point4D_homogeneous);
   

    // å°†é½æ¬¡åæ ‡è½¬æ¢ä¸ºä¸‰ç»´åæ ‡
    Mat point3D;
    convertPointsFromHomogeneous(point4D_homogeneous.t(), point3D);
    cout << point3D << endl;

    // è·å–ç‰¹å¾ç‚¹çš„é¢œè‰²ä¿¡æ¯
    vector<Vec3b> colors1, colors2; // é¢œè‰²ä¿¡æ¯

    for (Point2f& inlierPoints : inlierPoints1)
    {
        int x = cvRound(inlierPoints.x); // å…³é”®ç‚¹çš„xåæ ‡
        int y = cvRound(inlierPoints.y); // å…³é”®ç‚¹çš„yåæ ‡
        Vec3b color = img1.at<Vec3b>(y, x);
        colors1.push_back(color);
    }

    for (Point2f& inlierPoints : inlierPoints2)
    {
        int x = cvRound(inlierPoints.x); // å…³é”®ç‚¹çš„xåæ ‡
        int y = cvRound(inlierPoints.y); // å…³é”®ç‚¹çš„yåæ ‡
        Vec3b color = img2.at<Vec3b>(y, x);
        colors2.push_back(color);
    }

    // åˆ›å»ºå¸¦é¢œè‰²çš„ç‚¹äº‘æ•°æ®ç»“æ„
    vector<Point3f> pointCloud;
    vector<Vec3b> pointColors;

    // å…³è”é¢œè‰²ä¿¡æ¯åˆ°ç‚¹äº‘
    for (int i = 0; i < point3D.rows; ++i)
    {
        Point3f point = point3D.at<Point3f>(i);
        Vec3b color1 = colors1[i];
        Vec3b color2 = colors2[i];

        // åœ¨è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©ä½¿ç”¨å“ªä¸ªé¢œè‰²ï¼Œæˆ–è€…è¿›è¡Œé¢œè‰²æ’å€¼ç­‰å¤„ç†
        Vec3b finalColor = color1; // è¿™é‡Œç¤ºä¾‹ä½¿ç”¨ç¬¬ä¸€ä¸ªç›¸æœºçš„é¢œè‰²

        pointCloud.push_back(point);
        pointColors.push_back(finalColor);
    }

    // æ‰‹åŠ¨è¾“å‡ºç‚¹äº‘plyæ–‡ä»¶
    ofstream plyFile(PLY_SAVE_PATH);

    // plyçš„å¤´éƒ¨ä¿¡æ¯
    plyFile << "ply\n";
    plyFile << "format ascii 1.0\n";
    plyFile << "element vertex " << point3D.rows << "\n";
    plyFile << "property float x\n";
    plyFile << "property float y\n";
    plyFile << "property float z\n";
    plyFile << "property uchar blue\n";
    plyFile << "property uchar green\n";
    plyFile << "property uchar red\n";
    plyFile << "end_header\n";

    // å†™å…¥ç‚¹äº‘æ•°æ®
    for (int i = 0; i < point3D.rows; ++i)
    {
        Vec3b color = pointColors[i];
        const float* point = point3D.ptr<float>(i);
        plyFile << point[0] << " " << point[1] << " " << point[2] << " "
                << static_cast<int>(color[0]) << " "
                << static_cast<int>(color[1]) << " "
                << static_cast<int>(color[2]) << endl;
    }

    plyFile.close();   
    return 0;
}
```

æœ€ç»ˆæ•ˆæœï¼š

> ç‰¹åˆ«æé†’ï¼šç”¨ *meshlab* æ‰“å¼€åè®°å¾—åœ¨å³ä¾§çš„è®¾ç½®æ¡†ä¸­å°† **shading** æ”¹ä¸º**None** ï¼ï¼ï¼è¿™æ ·æ‰èƒ½çœ‹åˆ°çœŸæ­£çš„é¢œè‰²ï¼Œä¹Ÿå¯ä»¥æŠŠç‚¹è°ƒå¤§ä¸€ç‚¹å¥½çœ‹äº›
>
> <img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-09-25/image-20230925090744151.png" alt="image-20230925090744151" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-09-25/image-20230925090905231.png" alt="image-20230925090905231" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-09-25/100_7103.JPG" alt="100_7103" style="zoom: 35%;" />
